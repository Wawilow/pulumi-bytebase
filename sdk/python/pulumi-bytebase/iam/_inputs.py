# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'PolicyIamPolicyArgs',
    'PolicyIamPolicyArgsDict',
    'PolicyIamPolicyBindingArgs',
    'PolicyIamPolicyBindingArgsDict',
    'PolicyIamPolicyBindingConditionArgs',
    'PolicyIamPolicyBindingConditionArgsDict',
    'GetPolicyIamPolicyArgs',
    'GetPolicyIamPolicyArgsDict',
    'GetPolicyIamPolicyBindingArgs',
    'GetPolicyIamPolicyBindingArgsDict',
    'GetPolicyIamPolicyBindingConditionArgs',
    'GetPolicyIamPolicyBindingConditionArgsDict',
]

MYPY = False

if not MYPY:
    class PolicyIamPolicyArgsDict(TypedDict):
        bindings: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicyIamPolicyBindingArgsDict']]]]
        """
        The binding in the IAM policy.
        """
elif False:
    PolicyIamPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyIamPolicyArgs:
    def __init__(__self__, *,
                 bindings: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyIamPolicyBindingArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PolicyIamPolicyBindingArgs']]] bindings: The binding in the IAM policy.
        """
        if bindings is not None:
            pulumi.set(__self__, "bindings", bindings)

    @_builtins.property
    @pulumi.getter
    def bindings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicyIamPolicyBindingArgs']]]]:
        """
        The binding in the IAM policy.
        """
        return pulumi.get(self, "bindings")

    @bindings.setter
    def bindings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyIamPolicyBindingArgs']]]]):
        pulumi.set(self, "bindings", value)


if not MYPY:
    class PolicyIamPolicyBindingArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicyIamPolicyBindingConditionArgsDict']]]]
        """
        Match the condition limit.
        """
        members: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A set of memebers. The value can be "allUsers", "user:{email}" or "group:{email}".
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role full name in roles/{id} format.
        """
elif False:
    PolicyIamPolicyBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyIamPolicyBindingArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyIamPolicyBindingConditionArgs']]]] = None,
                 members: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PolicyIamPolicyBindingConditionArgs']]] conditions: Match the condition limit.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] members: A set of memebers. The value can be "allUsers", "user:{email}" or "group:{email}".
        :param pulumi.Input[_builtins.str] role: The role full name in roles/{id} format.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if members is not None:
            pulumi.set(__self__, "members", members)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicyIamPolicyBindingConditionArgs']]]]:
        """
        Match the condition limit.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyIamPolicyBindingConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A set of memebers. The value can be "allUsers", "user:{email}" or "group:{email}".
        """
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "members", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role full name in roles/{id} format.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class PolicyIamPolicyBindingConditionArgsDict(TypedDict):
        database: NotRequired[pulumi.Input[_builtins.str]]
        """
        The accessible database full name in instances/{instance resource id}/databases/{database name} format
        """
        expire_timestamp: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expiration timestamp in YYYY-MM-DDThh:mm:ssZ format
        """
        row_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        The export row limit for exporter role
        """
        schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        The accessible schema in the database
        """
        tables: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The accessible table list
        """
elif False:
    PolicyIamPolicyBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyIamPolicyBindingConditionArgs:
    def __init__(__self__, *,
                 database: Optional[pulumi.Input[_builtins.str]] = None,
                 expire_timestamp: Optional[pulumi.Input[_builtins.str]] = None,
                 row_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 schema: Optional[pulumi.Input[_builtins.str]] = None,
                 tables: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] database: The accessible database full name in instances/{instance resource id}/databases/{database name} format
        :param pulumi.Input[_builtins.str] expire_timestamp: The expiration timestamp in YYYY-MM-DDThh:mm:ssZ format
        :param pulumi.Input[_builtins.int] row_limit: The export row limit for exporter role
        :param pulumi.Input[_builtins.str] schema: The accessible schema in the database
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tables: The accessible table list
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if expire_timestamp is not None:
            pulumi.set(__self__, "expire_timestamp", expire_timestamp)
        if row_limit is not None:
            pulumi.set(__self__, "row_limit", row_limit)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The accessible database full name in instances/{instance resource id}/databases/{database name} format
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="expireTimestamp")
    def expire_timestamp(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expiration timestamp in YYYY-MM-DDThh:mm:ssZ format
        """
        return pulumi.get(self, "expire_timestamp")

    @expire_timestamp.setter
    def expire_timestamp(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expire_timestamp", value)

    @_builtins.property
    @pulumi.getter(name="rowLimit")
    def row_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The export row limit for exporter role
        """
        return pulumi.get(self, "row_limit")

    @row_limit.setter
    def row_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "row_limit", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The accessible schema in the database
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema", value)

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The accessible table list
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class GetPolicyIamPolicyArgsDict(TypedDict):
        bindings: NotRequired[Sequence['GetPolicyIamPolicyBindingArgsDict']]
        """
        The binding in the IAM policy.
        """
elif False:
    GetPolicyIamPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPolicyIamPolicyArgs:
    def __init__(__self__, *,
                 bindings: Optional[Sequence['GetPolicyIamPolicyBindingArgs']] = None):
        """
        :param Sequence['GetPolicyIamPolicyBindingArgs'] bindings: The binding in the IAM policy.
        """
        if bindings is not None:
            pulumi.set(__self__, "bindings", bindings)

    @_builtins.property
    @pulumi.getter
    def bindings(self) -> Optional[Sequence['GetPolicyIamPolicyBindingArgs']]:
        """
        The binding in the IAM policy.
        """
        return pulumi.get(self, "bindings")

    @bindings.setter
    def bindings(self, value: Optional[Sequence['GetPolicyIamPolicyBindingArgs']]):
        pulumi.set(self, "bindings", value)


if not MYPY:
    class GetPolicyIamPolicyBindingArgsDict(TypedDict):
        conditions: NotRequired[Sequence['GetPolicyIamPolicyBindingConditionArgsDict']]
        """
        Match the condition limit.
        """
        members: NotRequired[Sequence[_builtins.str]]
        """
        A set of memebers. The value can be "allUsers", "user:{email}" or "group:{email}".
        """
        role: NotRequired[_builtins.str]
        """
        The role full name in roles/{id} format.
        """
elif False:
    GetPolicyIamPolicyBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPolicyIamPolicyBindingArgs:
    def __init__(__self__, *,
                 conditions: Optional[Sequence['GetPolicyIamPolicyBindingConditionArgs']] = None,
                 members: Optional[Sequence[_builtins.str]] = None,
                 role: Optional[_builtins.str] = None):
        """
        :param Sequence['GetPolicyIamPolicyBindingConditionArgs'] conditions: Match the condition limit.
        :param Sequence[_builtins.str] members: A set of memebers. The value can be "allUsers", "user:{email}" or "group:{email}".
        :param _builtins.str role: The role full name in roles/{id} format.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if members is not None:
            pulumi.set(__self__, "members", members)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['GetPolicyIamPolicyBindingConditionArgs']]:
        """
        Match the condition limit.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[Sequence['GetPolicyIamPolicyBindingConditionArgs']]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def members(self) -> Optional[Sequence[_builtins.str]]:
        """
        A set of memebers. The value can be "allUsers", "user:{email}" or "group:{email}".
        """
        return pulumi.get(self, "members")

    @members.setter
    def members(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "members", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        The role full name in roles/{id} format.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[_builtins.str]):
        pulumi.set(self, "role", value)


if not MYPY:
    class GetPolicyIamPolicyBindingConditionArgsDict(TypedDict):
        database: NotRequired[_builtins.str]
        """
        The accessible database full name in instances/{instance resource id}/databases/{database name} format
        """
        expire_timestamp: NotRequired[_builtins.str]
        """
        The expiration timestamp in YYYY-MM-DDThh:mm:ssZ format
        """
        row_limit: NotRequired[_builtins.int]
        """
        The export row limit for exporter role
        """
        schema: NotRequired[_builtins.str]
        """
        The accessible schema in the database
        """
        tables: NotRequired[Sequence[_builtins.str]]
        """
        The accessible table list
        """
elif False:
    GetPolicyIamPolicyBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPolicyIamPolicyBindingConditionArgs:
    def __init__(__self__, *,
                 database: Optional[_builtins.str] = None,
                 expire_timestamp: Optional[_builtins.str] = None,
                 row_limit: Optional[_builtins.int] = None,
                 schema: Optional[_builtins.str] = None,
                 tables: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str database: The accessible database full name in instances/{instance resource id}/databases/{database name} format
        :param _builtins.str expire_timestamp: The expiration timestamp in YYYY-MM-DDThh:mm:ssZ format
        :param _builtins.int row_limit: The export row limit for exporter role
        :param _builtins.str schema: The accessible schema in the database
        :param Sequence[_builtins.str] tables: The accessible table list
        """
        if database is not None:
            pulumi.set(__self__, "database", database)
        if expire_timestamp is not None:
            pulumi.set(__self__, "expire_timestamp", expire_timestamp)
        if row_limit is not None:
            pulumi.set(__self__, "row_limit", row_limit)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The accessible database full name in instances/{instance resource id}/databases/{database name} format
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[_builtins.str]):
        pulumi.set(self, "database", value)

    @_builtins.property
    @pulumi.getter(name="expireTimestamp")
    def expire_timestamp(self) -> Optional[_builtins.str]:
        """
        The expiration timestamp in YYYY-MM-DDThh:mm:ssZ format
        """
        return pulumi.get(self, "expire_timestamp")

    @expire_timestamp.setter
    def expire_timestamp(self, value: Optional[_builtins.str]):
        pulumi.set(self, "expire_timestamp", value)

    @_builtins.property
    @pulumi.getter(name="rowLimit")
    def row_limit(self) -> Optional[_builtins.int]:
        """
        The export row limit for exporter role
        """
        return pulumi.get(self, "row_limit")

    @row_limit.setter
    def row_limit(self, value: Optional[_builtins.int]):
        pulumi.set(self, "row_limit", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        """
        The accessible schema in the database
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[_builtins.str]):
        pulumi.set(self, "schema", value)

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[Sequence[_builtins.str]]:
        """
        The accessible table list
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "tables", value)


