# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'DatabaseCatalog',
    'DatabaseCatalogSchema',
    'DatabaseCatalogSchemaTable',
    'DatabaseCatalogSchemaTableColumn',
    'GroupMember',
    'InstanceDataSource',
    'InstanceDataSourceExternalSecret',
    'InstanceDataSourceExternalSecretAwsSecretsManager',
    'InstanceDataSourceExternalSecretGcpSecretManager',
    'InstanceDataSourceExternalSecretVault',
    'InstanceDataSourceExternalSecretVaultAppRole',
    'PolicyDataSourceQueryPolicy',
    'PolicyDisableCopyDataPolicy',
    'PolicyGlobalMaskingPolicy',
    'PolicyGlobalMaskingPolicyRule',
    'PolicyMaskingExceptionPolicy',
    'PolicyMaskingExceptionPolicyException',
    'PolicyRolloutPolicy',
    'ProjectWebhook',
    'SettingApprovalFlow',
    'SettingApprovalFlowRule',
    'SettingApprovalFlowRuleCondition',
    'SettingApprovalFlowRuleFlow',
    'SettingApprovalFlowRuleFlowStep',
    'SettingClassification',
    'SettingClassificationClassification',
    'SettingClassificationLevel',
    'SettingEnvironmentSetting',
    'SettingEnvironmentSettingEnvironment',
    'SettingPasswordRestriction',
    'SettingSemanticType',
    'SettingSemanticTypeAlgorithm',
    'SettingSemanticTypeAlgorithmFullMask',
    'SettingSemanticTypeAlgorithmInnerOuterMask',
    'SettingSemanticTypeAlgorithmMd5Mask',
    'SettingSemanticTypeAlgorithmRangeMask',
    'SettingSemanticTypeAlgorithmRangeMaskSlice',
    'SettingSqlQueryRestriction',
    'SettingWorkspaceProfile',
    'SettingWorkspaceProfileAnnouncement',
    'GetDatabaseCatalogResult',
    'GetDatabaseCatalogSchemaResult',
    'GetDatabaseCatalogSchemaTableResult',
    'GetDatabaseCatalogSchemaTableColumnResult',
    'GetGroupMemberResult',
    'GetInstanceDataSourceResult',
    'GetInstanceDataSourceExternalSecretResult',
    'GetInstanceDataSourceExternalSecretAwsSecretsManagerResult',
    'GetInstanceDataSourceExternalSecretGcpSecretManagerResult',
    'GetInstanceDataSourceExternalSecretVaultResult',
    'GetInstanceDataSourceExternalSecretVaultAppRoleResult',
    'GetPolicyDataSourceQueryPolicyResult',
    'GetPolicyDisableCopyDataPolicyResult',
    'GetPolicyGlobalMaskingPolicyResult',
    'GetPolicyGlobalMaskingPolicyRuleResult',
    'GetPolicyMaskingExceptionPolicyResult',
    'GetPolicyMaskingExceptionPolicyExceptionResult',
    'GetPolicyRolloutPolicyResult',
    'GetProjectWebhookResult',
    'GetSettingApprovalFlowResult',
    'GetSettingApprovalFlowRuleResult',
    'GetSettingApprovalFlowRuleConditionResult',
    'GetSettingApprovalFlowRuleFlowResult',
    'GetSettingApprovalFlowRuleFlowStepResult',
    'GetSettingClassificationResult',
    'GetSettingClassificationClassificationResult',
    'GetSettingClassificationLevelResult',
    'GetSettingEnvironmentSettingResult',
    'GetSettingEnvironmentSettingEnvironmentResult',
    'GetSettingPasswordRestrictionResult',
    'GetSettingSemanticTypeResult',
    'GetSettingSemanticTypeAlgorithmResult',
    'GetSettingSemanticTypeAlgorithmFullMaskResult',
    'GetSettingSemanticTypeAlgorithmInnerOuterMaskResult',
    'GetSettingSemanticTypeAlgorithmMd5MaskResult',
    'GetSettingSemanticTypeAlgorithmRangeMaskResult',
    'GetSettingSemanticTypeAlgorithmRangeMaskSliceResult',
    'GetSettingSqlQueryRestrictionResult',
    'GetSettingWorkspaceProfileResult',
    'GetSettingWorkspaceProfileAnnouncementResult',
]

@pulumi.output_type
class DatabaseCatalog(dict):
    def __init__(__self__, *,
                 schemas: Sequence['outputs.DatabaseCatalogSchema']):
        pulumi.set(__self__, "schemas", schemas)

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Sequence['outputs.DatabaseCatalogSchema']:
        return pulumi.get(self, "schemas")


@pulumi.output_type
class DatabaseCatalogSchema(dict):
    def __init__(__self__, *,
                 tables: Sequence['outputs.DatabaseCatalogSchemaTable'],
                 name: Optional[_builtins.str] = None):
        pulumi.set(__self__, "tables", tables)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Sequence['outputs.DatabaseCatalogSchemaTable']:
        return pulumi.get(self, "tables")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class DatabaseCatalogSchemaTable(dict):
    def __init__(__self__, *,
                 columns: Sequence['outputs.DatabaseCatalogSchemaTableColumn'],
                 name: _builtins.str,
                 classification: Optional[_builtins.str] = None):
        """
        :param _builtins.str classification: The classification id
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "name", name)
        if classification is not None:
            pulumi.set(__self__, "classification", classification)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.DatabaseCatalogSchemaTableColumn']:
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def classification(self) -> Optional[_builtins.str]:
        """
        The classification id
        """
        return pulumi.get(self, "classification")


@pulumi.output_type
class DatabaseCatalogSchemaTableColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "semanticType":
            suggest = "semantic_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseCatalogSchemaTableColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseCatalogSchemaTableColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseCatalogSchemaTableColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 classification: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 semantic_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str classification: The classification id
        :param _builtins.str semantic_type: The semantic type id
        """
        pulumi.set(__self__, "name", name)
        if classification is not None:
            pulumi.set(__self__, "classification", classification)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if semantic_type is not None:
            pulumi.set(__self__, "semantic_type", semantic_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def classification(self) -> Optional[_builtins.str]:
        """
        The classification id
        """
        return pulumi.get(self, "classification")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="semanticType")
    def semantic_type(self) -> Optional[_builtins.str]:
        """
        The semantic type id
        """
        return pulumi.get(self, "semantic_type")


@pulumi.output_type
class GroupMember(dict):
    def __init__(__self__, *,
                 member: _builtins.str,
                 role: _builtins.str):
        """
        :param _builtins.str member: The member in users/{email} format.
        :param _builtins.str role: The member's role in the group, should be OWNER or MEMBER.
        """
        pulumi.set(__self__, "member", member)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def member(self) -> _builtins.str:
        """
        The member in users/{email} format.
        """
        return pulumi.get(self, "member")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The member's role in the group, should be OWNER or MEMBER.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class InstanceDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalSecret":
            suggest = "external_secret"
        elif key == "sslCa":
            suggest = "ssl_ca"
        elif key == "sslCert":
            suggest = "ssl_cert"
        elif key == "sslKey":
            suggest = "ssl_key"
        elif key == "useSsl":
            suggest = "use_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: _builtins.str,
                 id: _builtins.str,
                 port: _builtins.str,
                 type: _builtins.str,
                 database: Optional[_builtins.str] = None,
                 external_secret: Optional['outputs.InstanceDataSourceExternalSecret'] = None,
                 password: Optional[_builtins.str] = None,
                 ssl_ca: Optional[_builtins.str] = None,
                 ssl_cert: Optional[_builtins.str] = None,
                 ssl_key: Optional[_builtins.str] = None,
                 use_ssl: Optional[_builtins.bool] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str host: Host or socket for your instance, or the account name if the instance type is Snowflake.
        :param _builtins.str id: The unique data source id in this instance.
        :param _builtins.str port: The port for your instance.
        :param _builtins.str type: The data source type. Should be ADMIN or READ_ONLY.
        :param _builtins.str database: The database for the instance, you can set this if the engine type is POSTGRES.
        :param 'InstanceDataSourceExternalSecretArgs' external_secret: The external secret to get the database password. Learn more: https://www.bytebase.com/docs/get-started/instance/#use-external-secret-manager
        :param _builtins.str password: The connection user password used by Bytebase to perform DDL and DML operations.
        :param _builtins.str ssl_ca: The CA certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        :param _builtins.str ssl_cert: The client certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        :param _builtins.str ssl_key: The client key. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        :param _builtins.bool use_ssl: Enable SSL connection. Required to use SSL certificates.
        :param _builtins.str username: The connection user name used by Bytebase to perform DDL and DML operations.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "type", type)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if external_secret is not None:
            pulumi.set(__self__, "external_secret", external_secret)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssl_ca is not None:
            pulumi.set(__self__, "ssl_ca", ssl_ca)
        if ssl_cert is not None:
            pulumi.set(__self__, "ssl_cert", ssl_cert)
        if ssl_key is not None:
            pulumi.set(__self__, "ssl_key", ssl_key)
        if use_ssl is not None:
            pulumi.set(__self__, "use_ssl", use_ssl)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Host or socket for your instance, or the account name if the instance type is Snowflake.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique data source id in this instance.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        """
        The port for your instance.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The data source type. Should be ADMIN or READ_ONLY.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        The database for the instance, you can set this if the engine type is POSTGRES.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="externalSecret")
    def external_secret(self) -> Optional['outputs.InstanceDataSourceExternalSecret']:
        """
        The external secret to get the database password. Learn more: https://www.bytebase.com/docs/get-started/instance/#use-external-secret-manager
        """
        return pulumi.get(self, "external_secret")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        The connection user password used by Bytebase to perform DDL and DML operations.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="sslCa")
    def ssl_ca(self) -> Optional[_builtins.str]:
        """
        The CA certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        """
        return pulumi.get(self, "ssl_ca")

    @_builtins.property
    @pulumi.getter(name="sslCert")
    def ssl_cert(self) -> Optional[_builtins.str]:
        """
        The client certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        """
        return pulumi.get(self, "ssl_cert")

    @_builtins.property
    @pulumi.getter(name="sslKey")
    def ssl_key(self) -> Optional[_builtins.str]:
        """
        The client key. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
        """
        return pulumi.get(self, "ssl_key")

    @_builtins.property
    @pulumi.getter(name="useSsl")
    def use_ssl(self) -> Optional[_builtins.bool]:
        """
        Enable SSL connection. Required to use SSL certificates.
        """
        return pulumi.get(self, "use_ssl")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The connection user name used by Bytebase to perform DDL and DML operations.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class InstanceDataSourceExternalSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsSecretsManager":
            suggest = "aws_secrets_manager"
        elif key == "gcpSecretManager":
            suggest = "gcp_secret_manager"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceDataSourceExternalSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceDataSourceExternalSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceDataSourceExternalSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_secrets_manager: Optional['outputs.InstanceDataSourceExternalSecretAwsSecretsManager'] = None,
                 gcp_secret_manager: Optional['outputs.InstanceDataSourceExternalSecretGcpSecretManager'] = None,
                 vault: Optional['outputs.InstanceDataSourceExternalSecretVault'] = None):
        """
        :param 'InstanceDataSourceExternalSecretAwsSecretsManagerArgs' aws_secrets_manager: The AWS Secrets Manager to get the database password. Reference doc https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html
        :param 'InstanceDataSourceExternalSecretGcpSecretManagerArgs' gcp_secret_manager: The GCP Secret Manager to get the database password. Reference doc https://cloud.google.com/secret-manager/docs
        """
        if aws_secrets_manager is not None:
            pulumi.set(__self__, "aws_secrets_manager", aws_secrets_manager)
        if gcp_secret_manager is not None:
            pulumi.set(__self__, "gcp_secret_manager", gcp_secret_manager)
        if vault is not None:
            pulumi.set(__self__, "vault", vault)

    @_builtins.property
    @pulumi.getter(name="awsSecretsManager")
    def aws_secrets_manager(self) -> Optional['outputs.InstanceDataSourceExternalSecretAwsSecretsManager']:
        """
        The AWS Secrets Manager to get the database password. Reference doc https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html
        """
        return pulumi.get(self, "aws_secrets_manager")

    @_builtins.property
    @pulumi.getter(name="gcpSecretManager")
    def gcp_secret_manager(self) -> Optional['outputs.InstanceDataSourceExternalSecretGcpSecretManager']:
        """
        The GCP Secret Manager to get the database password. Reference doc https://cloud.google.com/secret-manager/docs
        """
        return pulumi.get(self, "gcp_secret_manager")

    @_builtins.property
    @pulumi.getter
    def vault(self) -> Optional['outputs.InstanceDataSourceExternalSecretVault']:
        return pulumi.get(self, "vault")


@pulumi.output_type
class InstanceDataSourceExternalSecretAwsSecretsManager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordKeyName":
            suggest = "password_key_name"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceDataSourceExternalSecretAwsSecretsManager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceDataSourceExternalSecretAwsSecretsManager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceDataSourceExternalSecretAwsSecretsManager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_key_name: _builtins.str,
                 secret_name: _builtins.str):
        """
        :param _builtins.str password_key_name: The key name for the password.
        :param _builtins.str secret_name: The secret name to store the password.
        """
        pulumi.set(__self__, "password_key_name", password_key_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @_builtins.property
    @pulumi.getter(name="passwordKeyName")
    def password_key_name(self) -> _builtins.str:
        """
        The key name for the password.
        """
        return pulumi.get(self, "password_key_name")

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> _builtins.str:
        """
        The secret name to store the password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class InstanceDataSourceExternalSecretGcpSecretManager(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceDataSourceExternalSecretGcpSecretManager. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceDataSourceExternalSecretGcpSecretManager.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceDataSourceExternalSecretGcpSecretManager.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_name: _builtins.str):
        """
        :param _builtins.str secret_name: The secret name should be like "projects/{project-id}/secrets/{secret-id}".
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> _builtins.str:
        """
        The secret name should be like "projects/{project-id}/secrets/{secret-id}".
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class InstanceDataSourceExternalSecretVault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "engineName":
            suggest = "engine_name"
        elif key == "passwordKeyName":
            suggest = "password_key_name"
        elif key == "secretName":
            suggest = "secret_name"
        elif key == "appRole":
            suggest = "app_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceDataSourceExternalSecretVault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceDataSourceExternalSecretVault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceDataSourceExternalSecretVault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 engine_name: _builtins.str,
                 password_key_name: _builtins.str,
                 secret_name: _builtins.str,
                 url: _builtins.str,
                 app_role: Optional['outputs.InstanceDataSourceExternalSecretVaultAppRole'] = None,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.str engine_name: The name for secret engine.
        :param _builtins.str password_key_name: The key name for the password.
        :param _builtins.str secret_name: The secret name in the engine to store the password.
        :param _builtins.str url: The Vault URL.
        :param 'InstanceDataSourceExternalSecretVaultAppRoleArgs' app_role: The Vault app role to get the password.
        """
        pulumi.set(__self__, "engine_name", engine_name)
        pulumi.set(__self__, "password_key_name", password_key_name)
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "url", url)
        if app_role is not None:
            pulumi.set(__self__, "app_role", app_role)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter(name="engineName")
    def engine_name(self) -> _builtins.str:
        """
        The name for secret engine.
        """
        return pulumi.get(self, "engine_name")

    @_builtins.property
    @pulumi.getter(name="passwordKeyName")
    def password_key_name(self) -> _builtins.str:
        """
        The key name for the password.
        """
        return pulumi.get(self, "password_key_name")

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> _builtins.str:
        """
        The secret name in the engine to store the password.
        """
        return pulumi.get(self, "secret_name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Vault URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="appRole")
    def app_role(self) -> Optional['outputs.InstanceDataSourceExternalSecretVaultAppRole']:
        """
        The Vault app role to get the password.
        """
        return pulumi.get(self, "app_role")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "token")


@pulumi.output_type
class InstanceDataSourceExternalSecretVaultAppRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleId":
            suggest = "role_id"
        elif key == "secretType":
            suggest = "secret_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceDataSourceExternalSecretVaultAppRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceDataSourceExternalSecretVaultAppRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceDataSourceExternalSecretVaultAppRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_id: _builtins.str,
                 secret: _builtins.str,
                 secret_type: _builtins.str):
        """
        :param _builtins.str role_id: The app role id.
        :param _builtins.str secret: The secret id for the role without ttl.
        :param _builtins.str secret_type: The secret id type, can be PLAIN (plain text for the secret) or ENVIRONMENT (envirionment name for the secret).
        """
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "secret_type", secret_type)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        """
        The app role id.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The secret id for the role without ttl.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="secretType")
    def secret_type(self) -> _builtins.str:
        """
        The secret id type, can be PLAIN (plain text for the secret) or ENVIRONMENT (envirionment name for the secret).
        """
        return pulumi.get(self, "secret_type")


@pulumi.output_type
class PolicyDataSourceQueryPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disallowDdl":
            suggest = "disallow_ddl"
        elif key == "disallowDml":
            suggest = "disallow_dml"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyDataSourceQueryPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyDataSourceQueryPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyDataSourceQueryPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disallow_ddl: Optional[_builtins.bool] = None,
                 disallow_dml: Optional[_builtins.bool] = None,
                 restriction: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disallow_ddl: Disallow running DDL statements in the SQL editor.
        :param _builtins.bool disallow_dml: Disallow running DML statements in the SQL editor.
        :param _builtins.str restriction: RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
        """
        if disallow_ddl is not None:
            pulumi.set(__self__, "disallow_ddl", disallow_ddl)
        if disallow_dml is not None:
            pulumi.set(__self__, "disallow_dml", disallow_dml)
        if restriction is not None:
            pulumi.set(__self__, "restriction", restriction)

    @_builtins.property
    @pulumi.getter(name="disallowDdl")
    def disallow_ddl(self) -> Optional[_builtins.bool]:
        """
        Disallow running DDL statements in the SQL editor.
        """
        return pulumi.get(self, "disallow_ddl")

    @_builtins.property
    @pulumi.getter(name="disallowDml")
    def disallow_dml(self) -> Optional[_builtins.bool]:
        """
        Disallow running DML statements in the SQL editor.
        """
        return pulumi.get(self, "disallow_dml")

    @_builtins.property
    @pulumi.getter
    def restriction(self) -> Optional[_builtins.str]:
        """
        RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
        """
        return pulumi.get(self, "restriction")


@pulumi.output_type
class PolicyDisableCopyDataPolicy(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool):
        """
        :param _builtins.bool enable: Restrict data copying
        """
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Restrict data copying
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class PolicyGlobalMaskingPolicy(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.PolicyGlobalMaskingPolicyRule']] = None):
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.PolicyGlobalMaskingPolicyRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class PolicyGlobalMaskingPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "semanticType":
            suggest = "semantic_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyGlobalMaskingPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyGlobalMaskingPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyGlobalMaskingPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: _builtins.str,
                 id: _builtins.str,
                 semantic_type: _builtins.str,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str condition: The condition expression
        :param _builtins.str id: The unique rule id
        :param _builtins.str semantic_type: The semantic type id
        :param _builtins.str title: The title for the rule
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "semantic_type", semantic_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        The condition expression
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique rule id
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="semanticType")
    def semantic_type(self) -> _builtins.str:
        """
        The semantic type id
        """
        return pulumi.get(self, "semantic_type")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The title for the rule
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class PolicyMaskingExceptionPolicy(dict):
    def __init__(__self__, *,
                 exceptions: Optional[Sequence['outputs.PolicyMaskingExceptionPolicyException']] = None):
        if exceptions is not None:
            pulumi.set(__self__, "exceptions", exceptions)

    @_builtins.property
    @pulumi.getter
    def exceptions(self) -> Optional[Sequence['outputs.PolicyMaskingExceptionPolicyException']]:
        return pulumi.get(self, "exceptions")


@pulumi.output_type
class PolicyMaskingExceptionPolicyException(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expireTimestamp":
            suggest = "expire_timestamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyMaskingExceptionPolicyException. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyMaskingExceptionPolicyException.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyMaskingExceptionPolicyException.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 database: _builtins.str,
                 member: _builtins.str,
                 column: Optional[_builtins.str] = None,
                 expire_timestamp: Optional[_builtins.str] = None,
                 reason: Optional[_builtins.str] = None,
                 schema: Optional[_builtins.str] = None,
                 table: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The database full name in instances/{instance resource id}/databases/{database name} format
        :param _builtins.str member: The member in user:{email} or group:{email} format.
        :param _builtins.str expire_timestamp: The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
        :param _builtins.str reason: The reason for the masking exemption
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "member", member)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if expire_timestamp is not None:
            pulumi.set(__self__, "expire_timestamp", expire_timestamp)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if table is not None:
            pulumi.set(__self__, "table", table)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The database full name in instances/{instance resource id}/databases/{database name} format
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def member(self) -> _builtins.str:
        """
        The member in user:{email} or group:{email} format.
        """
        return pulumi.get(self, "member")

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="expireTimestamp")
    def expire_timestamp(self) -> Optional[_builtins.str]:
        """
        The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
        """
        return pulumi.get(self, "expire_timestamp")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[_builtins.str]:
        """
        The reason for the masking exemption
        """
        return pulumi.get(self, "reason")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def table(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "table")


@pulumi.output_type
class PolicyRolloutPolicy(dict):
    def __init__(__self__, *,
                 automatic: Optional[_builtins.bool] = None,
                 roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool automatic: If all check pass, the change will be rolled out and executed automatically.
        :param Sequence[_builtins.str] roles: If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
        """
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter
    def automatic(self) -> Optional[_builtins.bool]:
        """
        If all check pass, the change will be rolled out and executed automatically.
        """
        return pulumi.get(self, "automatic")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class ProjectWebhook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notificationTypes":
            suggest = "notification_types"
        elif key == "directMessage":
            suggest = "direct_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectWebhook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectWebhook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectWebhook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notification_types: Sequence[_builtins.str],
                 title: _builtins.str,
                 type: _builtins.str,
                 url: _builtins.str,
                 direct_message: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] notification_types: notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
        :param _builtins.str title: The webhook title
        :param _builtins.str type: The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
        :param _builtins.str url: The webhook URL
        :param _builtins.bool direct_message: If direct_message is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
        :param _builtins.str name: The webhook full name in projects/{resource id}/webhooks/{id} format.
        """
        pulumi.set(__self__, "notification_types", notification_types)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        if direct_message is not None:
            pulumi.set(__self__, "direct_message", direct_message)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="notificationTypes")
    def notification_types(self) -> Sequence[_builtins.str]:
        """
        notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
        """
        return pulumi.get(self, "notification_types")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The webhook title
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The webhook URL
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="directMessage")
    def direct_message(self) -> Optional[_builtins.bool]:
        """
        If direct_message is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
        """
        return pulumi.get(self, "direct_message")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The webhook full name in projects/{resource id}/webhooks/{id} format.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SettingApprovalFlow(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.SettingApprovalFlowRule']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.SettingApprovalFlowRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class SettingApprovalFlowRule(dict):
    def __init__(__self__, *,
                 flows: Sequence['outputs.SettingApprovalFlowRuleFlow'],
                 conditions: Optional[Sequence['outputs.SettingApprovalFlowRuleCondition']] = None):
        """
        :param Sequence['SettingApprovalFlowRuleConditionArgs'] conditions: Match any condition will trigger this approval flow.
        """
        pulumi.set(__self__, "flows", flows)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @_builtins.property
    @pulumi.getter
    def flows(self) -> Sequence['outputs.SettingApprovalFlowRuleFlow']:
        return pulumi.get(self, "flows")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.SettingApprovalFlowRuleCondition']]:
        """
        Match any condition will trigger this approval flow.
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class SettingApprovalFlowRuleCondition(dict):
    def __init__(__self__, *,
                 level: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class SettingApprovalFlowRuleFlow(dict):
    def __init__(__self__, *,
                 steps: Sequence['outputs.SettingApprovalFlowRuleFlowStep'],
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param Sequence['SettingApprovalFlowRuleFlowStepArgs'] steps: Approval flow following the step order.
        """
        pulumi.set(__self__, "steps", steps)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Sequence['outputs.SettingApprovalFlowRuleFlowStep']:
        """
        Approval flow following the step order.
        """
        return pulumi.get(self, "steps")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class SettingApprovalFlowRuleFlowStep(dict):
    def __init__(__self__, *,
                 role: _builtins.str):
        """
        :param _builtins.str role: The role require to review in this step
        """
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role require to review in this step
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class SettingClassification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classificationFromConfig":
            suggest = "classification_from_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingClassification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingClassification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingClassification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classifications: Sequence['outputs.SettingClassificationClassification'],
                 id: _builtins.str,
                 levels: Sequence['outputs.SettingClassificationLevel'],
                 title: _builtins.str,
                 classification_from_config: Optional[_builtins.bool] = None):
        """
        :param _builtins.str id: The classification unique uuid.
        :param _builtins.str title: The classification title. Optional.
        :param _builtins.bool classification_from_config: If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
        """
        pulumi.set(__self__, "classifications", classifications)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "levels", levels)
        pulumi.set(__self__, "title", title)
        if classification_from_config is not None:
            pulumi.set(__self__, "classification_from_config", classification_from_config)

    @_builtins.property
    @pulumi.getter
    def classifications(self) -> Sequence['outputs.SettingClassificationClassification']:
        return pulumi.get(self, "classifications")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The classification unique uuid.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def levels(self) -> Sequence['outputs.SettingClassificationLevel']:
        return pulumi.get(self, "levels")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The classification title. Optional.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="classificationFromConfig")
    def classification_from_config(self) -> Optional[_builtins.bool]:
        """
        If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
        """
        return pulumi.get(self, "classification_from_config")


@pulumi.output_type
class SettingClassificationClassification(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 level: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The classification unique id, must in {number}-{number} format.
        :param _builtins.str title: The classification title.
        :param _builtins.str description: The classification description.
        :param _builtins.str level: The classification level id.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if level is not None:
            pulumi.set(__self__, "level", level)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The classification unique id, must in {number}-{number} format.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The classification title.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The classification description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def level(self) -> Optional[_builtins.str]:
        """
        The classification level id.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class SettingClassificationLevel(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The classification level unique uuid.
        :param _builtins.str title: The classification level title.
        :param _builtins.str description: The classification level description.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The classification level unique uuid.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The classification level title.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The classification level description.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class SettingEnvironmentSetting(dict):
    def __init__(__self__, *,
                 environments: Sequence['outputs.SettingEnvironmentSettingEnvironment']):
        pulumi.set(__self__, "environments", environments)

    @_builtins.property
    @pulumi.getter
    def environments(self) -> Sequence['outputs.SettingEnvironmentSettingEnvironment']:
        return pulumi.get(self, "environments")


@pulumi.output_type
class SettingEnvironmentSettingEnvironment(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 title: _builtins.str,
                 color: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 protected: Optional[_builtins.bool] = None):
        """
        :param _builtins.str id: The environment unique id.
        :param _builtins.str title: The environment display name.
        :param _builtins.str color: The environment color.
        :param _builtins.str name: The environment readonly name in environments/{id} format.
        :param _builtins.bool protected: The environment is protected or not.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protected is not None:
            pulumi.set(__self__, "protected", protected)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The environment unique id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The environment display name.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The environment color.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The environment readonly name in environments/{id} format.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def protected(self) -> Optional[_builtins.bool]:
        """
        The environment is protected or not.
        """
        return pulumi.get(self, "protected")


@pulumi.output_type
class SettingPasswordRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minLength":
            suggest = "min_length"
        elif key == "passwordRotationInSeconds":
            suggest = "password_rotation_in_seconds"
        elif key == "requireLetter":
            suggest = "require_letter"
        elif key == "requireNumber":
            suggest = "require_number"
        elif key == "requireResetPasswordForFirstLogin":
            suggest = "require_reset_password_for_first_login"
        elif key == "requireSpecialCharacter":
            suggest = "require_special_character"
        elif key == "requireUppercaseLetter":
            suggest = "require_uppercase_letter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingPasswordRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingPasswordRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingPasswordRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_length: Optional[_builtins.int] = None,
                 password_rotation_in_seconds: Optional[_builtins.int] = None,
                 require_letter: Optional[_builtins.bool] = None,
                 require_number: Optional[_builtins.bool] = None,
                 require_reset_password_for_first_login: Optional[_builtins.bool] = None,
                 require_special_character: Optional[_builtins.bool] = None,
                 require_uppercase_letter: Optional[_builtins.bool] = None):
        """
        :param _builtins.int min_length: min_length is the minimum length for password, should no less than 8.
        :param _builtins.int password_rotation_in_seconds: password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
        :param _builtins.bool require_letter: require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
        :param _builtins.bool require_number: require_number requires the password must contains at least one number.
        :param _builtins.bool require_reset_password_for_first_login: require*reset*password*for*first_login requires users to reset their password after the 1st login.
        :param _builtins.bool require_special_character: require*special*character requires the password must contains at least one special character.
        :param _builtins.bool require_uppercase_letter: require*uppercase*letter requires the password must contains at least one upper case letter.
        """
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if password_rotation_in_seconds is not None:
            pulumi.set(__self__, "password_rotation_in_seconds", password_rotation_in_seconds)
        if require_letter is not None:
            pulumi.set(__self__, "require_letter", require_letter)
        if require_number is not None:
            pulumi.set(__self__, "require_number", require_number)
        if require_reset_password_for_first_login is not None:
            pulumi.set(__self__, "require_reset_password_for_first_login", require_reset_password_for_first_login)
        if require_special_character is not None:
            pulumi.set(__self__, "require_special_character", require_special_character)
        if require_uppercase_letter is not None:
            pulumi.set(__self__, "require_uppercase_letter", require_uppercase_letter)

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[_builtins.int]:
        """
        min_length is the minimum length for password, should no less than 8.
        """
        return pulumi.get(self, "min_length")

    @_builtins.property
    @pulumi.getter(name="passwordRotationInSeconds")
    def password_rotation_in_seconds(self) -> Optional[_builtins.int]:
        """
        password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
        """
        return pulumi.get(self, "password_rotation_in_seconds")

    @_builtins.property
    @pulumi.getter(name="requireLetter")
    def require_letter(self) -> Optional[_builtins.bool]:
        """
        require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
        """
        return pulumi.get(self, "require_letter")

    @_builtins.property
    @pulumi.getter(name="requireNumber")
    def require_number(self) -> Optional[_builtins.bool]:
        """
        require_number requires the password must contains at least one number.
        """
        return pulumi.get(self, "require_number")

    @_builtins.property
    @pulumi.getter(name="requireResetPasswordForFirstLogin")
    def require_reset_password_for_first_login(self) -> Optional[_builtins.bool]:
        """
        require*reset*password*for*first_login requires users to reset their password after the 1st login.
        """
        return pulumi.get(self, "require_reset_password_for_first_login")

    @_builtins.property
    @pulumi.getter(name="requireSpecialCharacter")
    def require_special_character(self) -> Optional[_builtins.bool]:
        """
        require*special*character requires the password must contains at least one special character.
        """
        return pulumi.get(self, "require_special_character")

    @_builtins.property
    @pulumi.getter(name="requireUppercaseLetter")
    def require_uppercase_letter(self) -> Optional[_builtins.bool]:
        """
        require*uppercase*letter requires the password must contains at least one upper case letter.
        """
        return pulumi.get(self, "require_uppercase_letter")


@pulumi.output_type
class SettingSemanticType(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 title: _builtins.str,
                 algorithm: Optional['outputs.SettingSemanticTypeAlgorithm'] = None,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The semantic type unique uuid.
        :param _builtins.str title: The semantic type title. Required.
        :param 'SettingSemanticTypeAlgorithmArgs' algorithm: The semantic type algorithm. Required.
        :param _builtins.str description: The semantic type description. Optional.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The semantic type unique uuid.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The semantic type title. Required.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional['outputs.SettingSemanticTypeAlgorithm']:
        """
        The semantic type algorithm. Required.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The semantic type description. Optional.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class SettingSemanticTypeAlgorithm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullMask":
            suggest = "full_mask"
        elif key == "innerOuterMask":
            suggest = "inner_outer_mask"
        elif key == "md5Mask":
            suggest = "md5_mask"
        elif key == "rangeMask":
            suggest = "range_mask"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSemanticTypeAlgorithm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSemanticTypeAlgorithm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSemanticTypeAlgorithm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 full_mask: Optional['outputs.SettingSemanticTypeAlgorithmFullMask'] = None,
                 inner_outer_mask: Optional['outputs.SettingSemanticTypeAlgorithmInnerOuterMask'] = None,
                 md5_mask: Optional['outputs.SettingSemanticTypeAlgorithmMd5Mask'] = None,
                 range_mask: Optional['outputs.SettingSemanticTypeAlgorithmRangeMask'] = None):
        if full_mask is not None:
            pulumi.set(__self__, "full_mask", full_mask)
        if inner_outer_mask is not None:
            pulumi.set(__self__, "inner_outer_mask", inner_outer_mask)
        if md5_mask is not None:
            pulumi.set(__self__, "md5_mask", md5_mask)
        if range_mask is not None:
            pulumi.set(__self__, "range_mask", range_mask)

    @_builtins.property
    @pulumi.getter(name="fullMask")
    def full_mask(self) -> Optional['outputs.SettingSemanticTypeAlgorithmFullMask']:
        return pulumi.get(self, "full_mask")

    @_builtins.property
    @pulumi.getter(name="innerOuterMask")
    def inner_outer_mask(self) -> Optional['outputs.SettingSemanticTypeAlgorithmInnerOuterMask']:
        return pulumi.get(self, "inner_outer_mask")

    @_builtins.property
    @pulumi.getter(name="md5Mask")
    def md5_mask(self) -> Optional['outputs.SettingSemanticTypeAlgorithmMd5Mask']:
        return pulumi.get(self, "md5_mask")

    @_builtins.property
    @pulumi.getter(name="rangeMask")
    def range_mask(self) -> Optional['outputs.SettingSemanticTypeAlgorithmRangeMask']:
        return pulumi.get(self, "range_mask")


@pulumi.output_type
class SettingSemanticTypeAlgorithmFullMask(dict):
    def __init__(__self__, *,
                 substitution: _builtins.str):
        """
        :param _builtins.str substitution: Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
        """
        pulumi.set(__self__, "substitution", substitution)

    @_builtins.property
    @pulumi.getter
    def substitution(self) -> _builtins.str:
        """
        Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
        """
        return pulumi.get(self, "substitution")


@pulumi.output_type
class SettingSemanticTypeAlgorithmInnerOuterMask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixLen":
            suggest = "prefix_len"
        elif key == "suffixLen":
            suggest = "suffix_len"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSemanticTypeAlgorithmInnerOuterMask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSemanticTypeAlgorithmInnerOuterMask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSemanticTypeAlgorithmInnerOuterMask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefix_len: _builtins.int,
                 substitution: _builtins.str,
                 suffix_len: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int prefix_len: The length of prefix.
        :param _builtins.str substitution: Substitution is the string used to replace the inner or outer substring.
        :param _builtins.int suffix_len: The length of suffix.
        :param _builtins.str type: INNER or OUTER.
        """
        pulumi.set(__self__, "prefix_len", prefix_len)
        pulumi.set(__self__, "substitution", substitution)
        pulumi.set(__self__, "suffix_len", suffix_len)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="prefixLen")
    def prefix_len(self) -> _builtins.int:
        """
        The length of prefix.
        """
        return pulumi.get(self, "prefix_len")

    @_builtins.property
    @pulumi.getter
    def substitution(self) -> _builtins.str:
        """
        Substitution is the string used to replace the inner or outer substring.
        """
        return pulumi.get(self, "substitution")

    @_builtins.property
    @pulumi.getter(name="suffixLen")
    def suffix_len(self) -> _builtins.int:
        """
        The length of suffix.
        """
        return pulumi.get(self, "suffix_len")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        INNER or OUTER.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SettingSemanticTypeAlgorithmMd5Mask(dict):
    def __init__(__self__, *,
                 salt: _builtins.str):
        """
        :param _builtins.str salt: Salt is the salt value to generate a different hash that with the word alone.
        """
        pulumi.set(__self__, "salt", salt)

    @_builtins.property
    @pulumi.getter
    def salt(self) -> _builtins.str:
        """
        Salt is the salt value to generate a different hash that with the word alone.
        """
        return pulumi.get(self, "salt")


@pulumi.output_type
class SettingSemanticTypeAlgorithmRangeMask(dict):
    def __init__(__self__, *,
                 slices: Optional[Sequence['outputs.SettingSemanticTypeAlgorithmRangeMaskSlice']] = None):
        if slices is not None:
            pulumi.set(__self__, "slices", slices)

    @_builtins.property
    @pulumi.getter
    def slices(self) -> Optional[Sequence['outputs.SettingSemanticTypeAlgorithmRangeMaskSlice']]:
        return pulumi.get(self, "slices")


@pulumi.output_type
class SettingSemanticTypeAlgorithmRangeMaskSlice(dict):
    def __init__(__self__, *,
                 end: _builtins.int,
                 start: _builtins.int,
                 substitution: _builtins.str):
        """
        :param _builtins.int end: End is the stop index of the original value, should be less than the length of the original value.
        :param _builtins.int start: Start is the start index of the original value, start from 0 and should be less than stop.
        :param _builtins.str substitution: Substitution is the string used to replace the OriginalValue[start:end).
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "substitution", substitution)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.int:
        """
        End is the stop index of the original value, should be less than the length of the original value.
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.int:
        """
        Start is the start index of the original value, start from 0 and should be less than stop.
        """
        return pulumi.get(self, "start")

    @_builtins.property
    @pulumi.getter
    def substitution(self) -> _builtins.str:
        """
        Substitution is the string used to replace the OriginalValue[start:end).
        """
        return pulumi.get(self, "substitution")


@pulumi.output_type
class SettingSqlQueryRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumResultRows":
            suggest = "maximum_result_rows"
        elif key == "maximumResultSize":
            suggest = "maximum_result_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingSqlQueryRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingSqlQueryRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingSqlQueryRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_result_rows: Optional[_builtins.int] = None,
                 maximum_result_size: Optional[_builtins.int] = None):
        """
        :param _builtins.int maximum_result_rows: The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
        :param _builtins.int maximum_result_size: The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
        """
        if maximum_result_rows is not None:
            pulumi.set(__self__, "maximum_result_rows", maximum_result_rows)
        if maximum_result_size is not None:
            pulumi.set(__self__, "maximum_result_size", maximum_result_size)

    @_builtins.property
    @pulumi.getter(name="maximumResultRows")
    def maximum_result_rows(self) -> Optional[_builtins.int]:
        """
        The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
        """
        return pulumi.get(self, "maximum_result_rows")

    @_builtins.property
    @pulumi.getter(name="maximumResultSize")
    def maximum_result_size(self) -> Optional[_builtins.int]:
        """
        The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
        """
        return pulumi.get(self, "maximum_result_size")


@pulumi.output_type
class SettingWorkspaceProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseChangeMode":
            suggest = "database_change_mode"
        elif key == "disallowPasswordSignin":
            suggest = "disallow_password_signin"
        elif key == "disallowSignup":
            suggest = "disallow_signup"
        elif key == "enforceIdentityDomain":
            suggest = "enforce_identity_domain"
        elif key == "externalUrl":
            suggest = "external_url"
        elif key == "maximumRoleExpirationInSeconds":
            suggest = "maximum_role_expiration_in_seconds"
        elif key == "tokenDurationInSeconds":
            suggest = "token_duration_in_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingWorkspaceProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingWorkspaceProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingWorkspaceProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 announcement: Optional['outputs.SettingWorkspaceProfileAnnouncement'] = None,
                 database_change_mode: Optional[_builtins.str] = None,
                 disallow_password_signin: Optional[_builtins.bool] = None,
                 disallow_signup: Optional[_builtins.bool] = None,
                 domains: Optional[Sequence[_builtins.str]] = None,
                 enforce_identity_domain: Optional[_builtins.bool] = None,
                 external_url: Optional[_builtins.str] = None,
                 maximum_role_expiration_in_seconds: Optional[_builtins.int] = None,
                 token_duration_in_seconds: Optional[_builtins.int] = None):
        """
        :param 'SettingWorkspaceProfileAnnouncementArgs' announcement: Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
        :param _builtins.str database_change_mode: The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
        :param _builtins.bool disallow_password_signin: Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
        :param _builtins.bool disallow_signup: Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
        :param Sequence[_builtins.str] domains: The workspace domain, e.g. bytebase.com. Required for the group
        :param _builtins.bool enforce_identity_domain: Only user and group from the domains can be created and login.
        :param _builtins.str external_url: The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
        :param _builtins.int maximum_role_expiration_in_seconds: The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
        :param _builtins.int token_duration_in_seconds: The duration for login token in seconds. The duration should be at least 3600 (one hour).
        """
        if announcement is not None:
            pulumi.set(__self__, "announcement", announcement)
        if database_change_mode is not None:
            pulumi.set(__self__, "database_change_mode", database_change_mode)
        if disallow_password_signin is not None:
            pulumi.set(__self__, "disallow_password_signin", disallow_password_signin)
        if disallow_signup is not None:
            pulumi.set(__self__, "disallow_signup", disallow_signup)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if enforce_identity_domain is not None:
            pulumi.set(__self__, "enforce_identity_domain", enforce_identity_domain)
        if external_url is not None:
            pulumi.set(__self__, "external_url", external_url)
        if maximum_role_expiration_in_seconds is not None:
            pulumi.set(__self__, "maximum_role_expiration_in_seconds", maximum_role_expiration_in_seconds)
        if token_duration_in_seconds is not None:
            pulumi.set(__self__, "token_duration_in_seconds", token_duration_in_seconds)

    @_builtins.property
    @pulumi.getter
    def announcement(self) -> Optional['outputs.SettingWorkspaceProfileAnnouncement']:
        """
        Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
        """
        return pulumi.get(self, "announcement")

    @_builtins.property
    @pulumi.getter(name="databaseChangeMode")
    def database_change_mode(self) -> Optional[_builtins.str]:
        """
        The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
        """
        return pulumi.get(self, "database_change_mode")

    @_builtins.property
    @pulumi.getter(name="disallowPasswordSignin")
    def disallow_password_signin(self) -> Optional[_builtins.bool]:
        """
        Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
        """
        return pulumi.get(self, "disallow_password_signin")

    @_builtins.property
    @pulumi.getter(name="disallowSignup")
    def disallow_signup(self) -> Optional[_builtins.bool]:
        """
        Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
        """
        return pulumi.get(self, "disallow_signup")

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        The workspace domain, e.g. bytebase.com. Required for the group
        """
        return pulumi.get(self, "domains")

    @_builtins.property
    @pulumi.getter(name="enforceIdentityDomain")
    def enforce_identity_domain(self) -> Optional[_builtins.bool]:
        """
        Only user and group from the domains can be created and login.
        """
        return pulumi.get(self, "enforce_identity_domain")

    @_builtins.property
    @pulumi.getter(name="externalUrl")
    def external_url(self) -> Optional[_builtins.str]:
        """
        The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
        """
        return pulumi.get(self, "external_url")

    @_builtins.property
    @pulumi.getter(name="maximumRoleExpirationInSeconds")
    def maximum_role_expiration_in_seconds(self) -> Optional[_builtins.int]:
        """
        The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
        """
        return pulumi.get(self, "maximum_role_expiration_in_seconds")

    @_builtins.property
    @pulumi.getter(name="tokenDurationInSeconds")
    def token_duration_in_seconds(self) -> Optional[_builtins.int]:
        """
        The duration for login token in seconds. The duration should be at least 3600 (one hour).
        """
        return pulumi.get(self, "token_duration_in_seconds")


@pulumi.output_type
class SettingWorkspaceProfileAnnouncement(dict):
    def __init__(__self__, *,
                 level: _builtins.str,
                 text: _builtins.str,
                 link: Optional[_builtins.str] = None):
        """
        :param _builtins.str level: The alert level of announcement
        :param _builtins.str text: The text of announcement. Leave it as empty string can clear the announcement
        :param _builtins.str link: The optional link, user can follow the link to check extra details
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "text", text)
        if link is not None:
            pulumi.set(__self__, "link", link)

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        """
        The alert level of announcement
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        The text of announcement. Leave it as empty string can clear the announcement
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter
    def link(self) -> Optional[_builtins.str]:
        """
        The optional link, user can follow the link to check extra details
        """
        return pulumi.get(self, "link")


@pulumi.output_type
class GetDatabaseCatalogResult(dict):
    def __init__(__self__, *,
                 schemas: Sequence['outputs.GetDatabaseCatalogSchemaResult']):
        pulumi.set(__self__, "schemas", schemas)

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Sequence['outputs.GetDatabaseCatalogSchemaResult']:
        return pulumi.get(self, "schemas")


@pulumi.output_type
class GetDatabaseCatalogSchemaResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 tables: Sequence['outputs.GetDatabaseCatalogSchemaTableResult']):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Sequence['outputs.GetDatabaseCatalogSchemaTableResult']:
        return pulumi.get(self, "tables")


@pulumi.output_type
class GetDatabaseCatalogSchemaTableResult(dict):
    def __init__(__self__, *,
                 classification: _builtins.str,
                 columns: Sequence['outputs.GetDatabaseCatalogSchemaTableColumnResult'],
                 name: _builtins.str):
        """
        :param _builtins.str classification: The classification id
        """
        pulumi.set(__self__, "classification", classification)
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> _builtins.str:
        """
        The classification id
        """
        return pulumi.get(self, "classification")

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.GetDatabaseCatalogSchemaTableColumnResult']:
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDatabaseCatalogSchemaTableColumnResult(dict):
    def __init__(__self__, *,
                 classification: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 semantic_type: _builtins.str):
        """
        :param _builtins.str classification: The classification id
        :param Mapping[str, _builtins.str] labels: The deployment and policy control labels.
        :param _builtins.str name: The database full name in instances/{instance}/databases/{database} format
        :param _builtins.str semantic_type: The semantic type id
        """
        pulumi.set(__self__, "classification", classification)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "semantic_type", semantic_type)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> _builtins.str:
        """
        The classification id
        """
        return pulumi.get(self, "classification")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        The deployment and policy control labels.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The database full name in instances/{instance}/databases/{database} format
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="semanticType")
    def semantic_type(self) -> _builtins.str:
        """
        The semantic type id
        """
        return pulumi.get(self, "semantic_type")


@pulumi.output_type
class GetGroupMemberResult(dict):
    def __init__(__self__, *,
                 member: _builtins.str,
                 role: _builtins.str):
        """
        :param _builtins.str member: The member in users/{email} format.
        :param _builtins.str role: The member's role in the group.
        """
        pulumi.set(__self__, "member", member)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def member(self) -> _builtins.str:
        """
        The member in users/{email} format.
        """
        return pulumi.get(self, "member")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The member's role in the group.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetInstanceDataSourceResult(dict):
    def __init__(__self__, *,
                 database: _builtins.str,
                 external_secrets: Sequence['outputs.GetInstanceDataSourceExternalSecretResult'],
                 host: _builtins.str,
                 id: _builtins.str,
                 password: _builtins.str,
                 port: _builtins.str,
                 ssl_ca: _builtins.str,
                 ssl_cert: _builtins.str,
                 ssl_key: _builtins.str,
                 type: _builtins.str,
                 use_ssl: _builtins.bool,
                 username: _builtins.str):
        """
        :param _builtins.str database: The database for the instance, you can set this if the engine type is POSTGRES.
        :param Sequence['GetInstanceDataSourceExternalSecretArgs'] external_secrets: The external secret to get the database password. Learn more: https://www.bytebase.com/docs/get-started/instance/#use-external-secret-manager
        :param _builtins.str host: Host or socket for your instance, or the account name if the instance type is Snowflake.
        :param _builtins.str id: The unique data source id in this instance.
        :param _builtins.str password: The connection user password used by Bytebase to perform DDL and DML operations.
        :param _builtins.str port: The port for your instance.
        :param _builtins.str ssl_ca: The CA certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB, CLICKHOUSE or COCKROACHDB.
        :param _builtins.str ssl_cert: The client certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB, CLICKHOUSE or COCKROACHDB.
        :param _builtins.str ssl_key: The client key. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB, CLICKHOUSE or COCKROACHDB.
        :param _builtins.str type: The data source type. Should be ADMIN or READ_ONLY.
        :param _builtins.bool use_ssl: Enable SSL connection. Required to use SSL certificates.
        :param _builtins.str username: The connection user name used by Bytebase to perform DDL and DML operations.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "external_secrets", external_secrets)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "ssl_ca", ssl_ca)
        pulumi.set(__self__, "ssl_cert", ssl_cert)
        pulumi.set(__self__, "ssl_key", ssl_key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "use_ssl", use_ssl)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The database for the instance, you can set this if the engine type is POSTGRES.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="externalSecrets")
    def external_secrets(self) -> Sequence['outputs.GetInstanceDataSourceExternalSecretResult']:
        """
        The external secret to get the database password. Learn more: https://www.bytebase.com/docs/get-started/instance/#use-external-secret-manager
        """
        return pulumi.get(self, "external_secrets")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Host or socket for your instance, or the account name if the instance type is Snowflake.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique data source id in this instance.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The connection user password used by Bytebase to perform DDL and DML operations.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        """
        The port for your instance.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="sslCa")
    def ssl_ca(self) -> _builtins.str:
        """
        The CA certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB, CLICKHOUSE or COCKROACHDB.
        """
        return pulumi.get(self, "ssl_ca")

    @_builtins.property
    @pulumi.getter(name="sslCert")
    def ssl_cert(self) -> _builtins.str:
        """
        The client certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB, CLICKHOUSE or COCKROACHDB.
        """
        return pulumi.get(self, "ssl_cert")

    @_builtins.property
    @pulumi.getter(name="sslKey")
    def ssl_key(self) -> _builtins.str:
        """
        The client key. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB, CLICKHOUSE or COCKROACHDB.
        """
        return pulumi.get(self, "ssl_key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The data source type. Should be ADMIN or READ_ONLY.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="useSsl")
    def use_ssl(self) -> _builtins.bool:
        """
        Enable SSL connection. Required to use SSL certificates.
        """
        return pulumi.get(self, "use_ssl")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The connection user name used by Bytebase to perform DDL and DML operations.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetInstanceDataSourceExternalSecretResult(dict):
    def __init__(__self__, *,
                 aws_secrets_managers: Sequence['outputs.GetInstanceDataSourceExternalSecretAwsSecretsManagerResult'],
                 gcp_secret_managers: Sequence['outputs.GetInstanceDataSourceExternalSecretGcpSecretManagerResult'],
                 vaults: Sequence['outputs.GetInstanceDataSourceExternalSecretVaultResult']):
        """
        :param Sequence['GetInstanceDataSourceExternalSecretAwsSecretsManagerArgs'] aws_secrets_managers: The AWS Secrets Manager to get the database password. Reference doc https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html
        :param Sequence['GetInstanceDataSourceExternalSecretGcpSecretManagerArgs'] gcp_secret_managers: The GCP Secret Manager to get the database password. Reference doc https://cloud.google.com/secret-manager/docs
        """
        pulumi.set(__self__, "aws_secrets_managers", aws_secrets_managers)
        pulumi.set(__self__, "gcp_secret_managers", gcp_secret_managers)
        pulumi.set(__self__, "vaults", vaults)

    @_builtins.property
    @pulumi.getter(name="awsSecretsManagers")
    def aws_secrets_managers(self) -> Sequence['outputs.GetInstanceDataSourceExternalSecretAwsSecretsManagerResult']:
        """
        The AWS Secrets Manager to get the database password. Reference doc https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html
        """
        return pulumi.get(self, "aws_secrets_managers")

    @_builtins.property
    @pulumi.getter(name="gcpSecretManagers")
    def gcp_secret_managers(self) -> Sequence['outputs.GetInstanceDataSourceExternalSecretGcpSecretManagerResult']:
        """
        The GCP Secret Manager to get the database password. Reference doc https://cloud.google.com/secret-manager/docs
        """
        return pulumi.get(self, "gcp_secret_managers")

    @_builtins.property
    @pulumi.getter
    def vaults(self) -> Sequence['outputs.GetInstanceDataSourceExternalSecretVaultResult']:
        return pulumi.get(self, "vaults")


@pulumi.output_type
class GetInstanceDataSourceExternalSecretAwsSecretsManagerResult(dict):
    def __init__(__self__, *,
                 password_key_name: _builtins.str,
                 secret_name: _builtins.str):
        """
        :param _builtins.str password_key_name: The key name for the password.
        :param _builtins.str secret_name: The secret name to store the password.
        """
        pulumi.set(__self__, "password_key_name", password_key_name)
        pulumi.set(__self__, "secret_name", secret_name)

    @_builtins.property
    @pulumi.getter(name="passwordKeyName")
    def password_key_name(self) -> _builtins.str:
        """
        The key name for the password.
        """
        return pulumi.get(self, "password_key_name")

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> _builtins.str:
        """
        The secret name to store the password.
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetInstanceDataSourceExternalSecretGcpSecretManagerResult(dict):
    def __init__(__self__, *,
                 secret_name: _builtins.str):
        """
        :param _builtins.str secret_name: The secret name should be like "projects/{project-id}/secrets/{secret-id}".
        """
        pulumi.set(__self__, "secret_name", secret_name)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> _builtins.str:
        """
        The secret name should be like "projects/{project-id}/secrets/{secret-id}".
        """
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class GetInstanceDataSourceExternalSecretVaultResult(dict):
    def __init__(__self__, *,
                 app_roles: Sequence['outputs.GetInstanceDataSourceExternalSecretVaultAppRoleResult'],
                 engine_name: _builtins.str,
                 password_key_name: _builtins.str,
                 secret_name: _builtins.str,
                 token: _builtins.str,
                 url: _builtins.str):
        """
        :param Sequence['GetInstanceDataSourceExternalSecretVaultAppRoleArgs'] app_roles: The Vault app role to get the password.
        :param _builtins.str engine_name: The name for secret engine.
        :param _builtins.str password_key_name: The key name for the password.
        :param _builtins.str secret_name: The secret name in the engine to store the password.
        :param _builtins.str url: The Vault URL.
        """
        pulumi.set(__self__, "app_roles", app_roles)
        pulumi.set(__self__, "engine_name", engine_name)
        pulumi.set(__self__, "password_key_name", password_key_name)
        pulumi.set(__self__, "secret_name", secret_name)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="appRoles")
    def app_roles(self) -> Sequence['outputs.GetInstanceDataSourceExternalSecretVaultAppRoleResult']:
        """
        The Vault app role to get the password.
        """
        return pulumi.get(self, "app_roles")

    @_builtins.property
    @pulumi.getter(name="engineName")
    def engine_name(self) -> _builtins.str:
        """
        The name for secret engine.
        """
        return pulumi.get(self, "engine_name")

    @_builtins.property
    @pulumi.getter(name="passwordKeyName")
    def password_key_name(self) -> _builtins.str:
        """
        The key name for the password.
        """
        return pulumi.get(self, "password_key_name")

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> _builtins.str:
        """
        The secret name in the engine to store the password.
        """
        return pulumi.get(self, "secret_name")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Vault URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetInstanceDataSourceExternalSecretVaultAppRoleResult(dict):
    def __init__(__self__, *,
                 role_id: _builtins.str,
                 secret: _builtins.str,
                 secret_type: _builtins.str):
        """
        :param _builtins.str role_id: The app role id.
        :param _builtins.str secret: The secret id for the role without ttl.
        :param _builtins.str secret_type: The secret id type, can be PLAIN (plain text for the secret) or ENVIRONMENT (envirionment name for the secret).
        """
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "secret_type", secret_type)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        """
        The app role id.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        The secret id for the role without ttl.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="secretType")
    def secret_type(self) -> _builtins.str:
        """
        The secret id type, can be PLAIN (plain text for the secret) or ENVIRONMENT (envirionment name for the secret).
        """
        return pulumi.get(self, "secret_type")


@pulumi.output_type
class GetPolicyDataSourceQueryPolicyResult(dict):
    def __init__(__self__, *,
                 disallow_ddl: Optional[_builtins.bool] = None,
                 disallow_dml: Optional[_builtins.bool] = None,
                 restriction: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disallow_ddl: Disallow running DDL statements in the SQL editor.
        :param _builtins.bool disallow_dml: Disallow running DML statements in the SQL editor.
        :param _builtins.str restriction: RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
        """
        if disallow_ddl is not None:
            pulumi.set(__self__, "disallow_ddl", disallow_ddl)
        if disallow_dml is not None:
            pulumi.set(__self__, "disallow_dml", disallow_dml)
        if restriction is not None:
            pulumi.set(__self__, "restriction", restriction)

    @_builtins.property
    @pulumi.getter(name="disallowDdl")
    def disallow_ddl(self) -> Optional[_builtins.bool]:
        """
        Disallow running DDL statements in the SQL editor.
        """
        return pulumi.get(self, "disallow_ddl")

    @_builtins.property
    @pulumi.getter(name="disallowDml")
    def disallow_dml(self) -> Optional[_builtins.bool]:
        """
        Disallow running DML statements in the SQL editor.
        """
        return pulumi.get(self, "disallow_dml")

    @_builtins.property
    @pulumi.getter
    def restriction(self) -> Optional[_builtins.str]:
        """
        RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
        """
        return pulumi.get(self, "restriction")


@pulumi.output_type
class GetPolicyDisableCopyDataPolicyResult(dict):
    def __init__(__self__, *,
                 enable: _builtins.bool):
        """
        :param _builtins.bool enable: Restrict data copying
        """
        pulumi.set(__self__, "enable", enable)

    @_builtins.property
    @pulumi.getter
    def enable(self) -> _builtins.bool:
        """
        Restrict data copying
        """
        return pulumi.get(self, "enable")


@pulumi.output_type
class GetPolicyGlobalMaskingPolicyResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetPolicyGlobalMaskingPolicyRuleResult']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetPolicyGlobalMaskingPolicyRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetPolicyGlobalMaskingPolicyRuleResult(dict):
    def __init__(__self__, *,
                 condition: _builtins.str,
                 id: _builtins.str,
                 semantic_type: _builtins.str,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str condition: The condition expression
        :param _builtins.str id: The unique rule id
        :param _builtins.str semantic_type: The semantic type id
        :param _builtins.str title: The title for the rule
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "semantic_type", semantic_type)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        The condition expression
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique rule id
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="semanticType")
    def semantic_type(self) -> _builtins.str:
        """
        The semantic type id
        """
        return pulumi.get(self, "semantic_type")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The title for the rule
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetPolicyMaskingExceptionPolicyResult(dict):
    def __init__(__self__, *,
                 exceptions: Sequence['outputs.GetPolicyMaskingExceptionPolicyExceptionResult']):
        pulumi.set(__self__, "exceptions", exceptions)

    @_builtins.property
    @pulumi.getter
    def exceptions(self) -> Sequence['outputs.GetPolicyMaskingExceptionPolicyExceptionResult']:
        return pulumi.get(self, "exceptions")


@pulumi.output_type
class GetPolicyMaskingExceptionPolicyExceptionResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 column: _builtins.str,
                 database: _builtins.str,
                 expire_timestamp: _builtins.str,
                 member: _builtins.str,
                 schema: _builtins.str,
                 table: _builtins.str,
                 reason: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: The database full name in instances/{instance resource id}/databases/{database name} format
        :param _builtins.str expire_timestamp: The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
        :param _builtins.str member: The member in user:{email} or group:{email} format.
        :param _builtins.str reason: The reason for the masking exemption
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "expire_timestamp", expire_timestamp)
        pulumi.set(__self__, "member", member)
        pulumi.set(__self__, "schema", schema)
        pulumi.set(__self__, "table", table)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def column(self) -> _builtins.str:
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        The database full name in instances/{instance resource id}/databases/{database name} format
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="expireTimestamp")
    def expire_timestamp(self) -> _builtins.str:
        """
        The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
        """
        return pulumi.get(self, "expire_timestamp")

    @_builtins.property
    @pulumi.getter
    def member(self) -> _builtins.str:
        """
        The member in user:{email} or group:{email} format.
        """
        return pulumi.get(self, "member")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> _builtins.str:
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[_builtins.str]:
        """
        The reason for the masking exemption
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class GetPolicyRolloutPolicyResult(dict):
    def __init__(__self__, *,
                 automatic: Optional[_builtins.bool] = None,
                 roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool automatic: If all check pass, the change will be rolled out and executed automatically.
        :param Sequence[_builtins.str] roles: If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
        """
        if automatic is not None:
            pulumi.set(__self__, "automatic", automatic)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter
    def automatic(self) -> Optional[_builtins.bool]:
        """
        If all check pass, the change will be rolled out and executed automatically.
        """
        return pulumi.get(self, "automatic")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetProjectWebhookResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 notification_types: Sequence[_builtins.str],
                 title: _builtins.str,
                 type: _builtins.str,
                 url: _builtins.str,
                 direct_message: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The webhook full name in projects/{resource id}/webhooks/{id} format.
        :param Sequence[_builtins.str] notification_types: notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
        :param _builtins.str title: The webhook title
        :param _builtins.str type: The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
        :param _builtins.str url: The webhook URL
        :param _builtins.bool direct_message: If direct_message is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notification_types", notification_types)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        if direct_message is not None:
            pulumi.set(__self__, "direct_message", direct_message)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The webhook full name in projects/{resource id}/webhooks/{id} format.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notificationTypes")
    def notification_types(self) -> Sequence[_builtins.str]:
        """
        notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
        """
        return pulumi.get(self, "notification_types")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The webhook title
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The webhook URL
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="directMessage")
    def direct_message(self) -> Optional[_builtins.bool]:
        """
        If direct_message is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
        """
        return pulumi.get(self, "direct_message")


@pulumi.output_type
class GetSettingApprovalFlowResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetSettingApprovalFlowRuleResult']):
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetSettingApprovalFlowRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetSettingApprovalFlowRuleResult(dict):
    def __init__(__self__, *,
                 conditions: Sequence['outputs.GetSettingApprovalFlowRuleConditionResult'],
                 flows: Sequence['outputs.GetSettingApprovalFlowRuleFlowResult']):
        """
        :param Sequence['GetSettingApprovalFlowRuleConditionArgs'] conditions: Match any condition will trigger this approval flow.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "flows", flows)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.GetSettingApprovalFlowRuleConditionResult']:
        """
        Match any condition will trigger this approval flow.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def flows(self) -> Sequence['outputs.GetSettingApprovalFlowRuleFlowResult']:
        return pulumi.get(self, "flows")


@pulumi.output_type
class GetSettingApprovalFlowRuleConditionResult(dict):
    def __init__(__self__, *,
                 level: _builtins.str,
                 source: _builtins.str):
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetSettingApprovalFlowRuleFlowResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 steps: Sequence['outputs.GetSettingApprovalFlowRuleFlowStepResult'],
                 title: _builtins.str):
        """
        :param Sequence['GetSettingApprovalFlowRuleFlowStepArgs'] steps: Approval flow following the step order.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "steps", steps)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Sequence['outputs.GetSettingApprovalFlowRuleFlowStepResult']:
        """
        Approval flow following the step order.
        """
        return pulumi.get(self, "steps")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSettingApprovalFlowRuleFlowStepResult(dict):
    def __init__(__self__, *,
                 role: _builtins.str):
        """
        :param _builtins.str role: The role require to review in this step
        """
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role require to review in this step
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetSettingClassificationResult(dict):
    def __init__(__self__, *,
                 classification_from_config: _builtins.bool,
                 classifications: Sequence['outputs.GetSettingClassificationClassificationResult'],
                 id: _builtins.str,
                 levels: Sequence['outputs.GetSettingClassificationLevelResult'],
                 title: _builtins.str):
        """
        :param _builtins.bool classification_from_config: If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
        :param _builtins.str id: The classification unique uuid.
        :param _builtins.str title: The classification title. Optional.
        """
        pulumi.set(__self__, "classification_from_config", classification_from_config)
        pulumi.set(__self__, "classifications", classifications)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "levels", levels)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="classificationFromConfig")
    def classification_from_config(self) -> _builtins.bool:
        """
        If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
        """
        return pulumi.get(self, "classification_from_config")

    @_builtins.property
    @pulumi.getter
    def classifications(self) -> Sequence['outputs.GetSettingClassificationClassificationResult']:
        return pulumi.get(self, "classifications")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The classification unique uuid.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def levels(self) -> Sequence['outputs.GetSettingClassificationLevelResult']:
        return pulumi.get(self, "levels")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The classification title. Optional.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSettingClassificationClassificationResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 level: _builtins.str,
                 title: _builtins.str):
        """
        :param _builtins.str description: The classification description.
        :param _builtins.str id: The classification unique id, must in {number}-{number} format.
        :param _builtins.str level: The classification level id.
        :param _builtins.str title: The classification title.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The classification description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The classification unique id, must in {number}-{number} format.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        """
        The classification level id.
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The classification title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSettingClassificationLevelResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 title: _builtins.str):
        """
        :param _builtins.str description: The classification level description.
        :param _builtins.str id: The classification level unique uuid.
        :param _builtins.str title: The classification level title.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The classification level description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The classification level unique uuid.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The classification level title.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSettingEnvironmentSettingResult(dict):
    def __init__(__self__, *,
                 environments: Sequence['outputs.GetSettingEnvironmentSettingEnvironmentResult']):
        pulumi.set(__self__, "environments", environments)

    @_builtins.property
    @pulumi.getter
    def environments(self) -> Sequence['outputs.GetSettingEnvironmentSettingEnvironmentResult']:
        return pulumi.get(self, "environments")


@pulumi.output_type
class GetSettingEnvironmentSettingEnvironmentResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 title: _builtins.str,
                 color: Optional[_builtins.str] = None,
                 protected: Optional[_builtins.bool] = None):
        """
        :param _builtins.str id: The environment unique id.
        :param _builtins.str name: The environment readonly name in environments/{id} format.
        :param _builtins.str title: The environment display name.
        :param _builtins.str color: The environment color.
        :param _builtins.bool protected: The environment is protected or not.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "title", title)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if protected is not None:
            pulumi.set(__self__, "protected", protected)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The environment unique id.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The environment readonly name in environments/{id} format.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The environment display name.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def color(self) -> Optional[_builtins.str]:
        """
        The environment color.
        """
        return pulumi.get(self, "color")

    @_builtins.property
    @pulumi.getter
    def protected(self) -> Optional[_builtins.bool]:
        """
        The environment is protected or not.
        """
        return pulumi.get(self, "protected")


@pulumi.output_type
class GetSettingPasswordRestrictionResult(dict):
    def __init__(__self__, *,
                 min_length: Optional[_builtins.int] = None,
                 password_rotation_in_seconds: Optional[_builtins.int] = None,
                 require_letter: Optional[_builtins.bool] = None,
                 require_number: Optional[_builtins.bool] = None,
                 require_reset_password_for_first_login: Optional[_builtins.bool] = None,
                 require_special_character: Optional[_builtins.bool] = None,
                 require_uppercase_letter: Optional[_builtins.bool] = None):
        """
        :param _builtins.int min_length: min_length is the minimum length for password, should no less than 8.
        :param _builtins.int password_rotation_in_seconds: password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
        :param _builtins.bool require_letter: require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
        :param _builtins.bool require_number: require_number requires the password must contains at least one number.
        :param _builtins.bool require_reset_password_for_first_login: require*reset*password*for*first_login requires users to reset their password after the 1st login.
        :param _builtins.bool require_special_character: require*special*character requires the password must contains at least one special character.
        :param _builtins.bool require_uppercase_letter: require*uppercase*letter requires the password must contains at least one upper case letter.
        """
        if min_length is not None:
            pulumi.set(__self__, "min_length", min_length)
        if password_rotation_in_seconds is not None:
            pulumi.set(__self__, "password_rotation_in_seconds", password_rotation_in_seconds)
        if require_letter is not None:
            pulumi.set(__self__, "require_letter", require_letter)
        if require_number is not None:
            pulumi.set(__self__, "require_number", require_number)
        if require_reset_password_for_first_login is not None:
            pulumi.set(__self__, "require_reset_password_for_first_login", require_reset_password_for_first_login)
        if require_special_character is not None:
            pulumi.set(__self__, "require_special_character", require_special_character)
        if require_uppercase_letter is not None:
            pulumi.set(__self__, "require_uppercase_letter", require_uppercase_letter)

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> Optional[_builtins.int]:
        """
        min_length is the minimum length for password, should no less than 8.
        """
        return pulumi.get(self, "min_length")

    @_builtins.property
    @pulumi.getter(name="passwordRotationInSeconds")
    def password_rotation_in_seconds(self) -> Optional[_builtins.int]:
        """
        password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
        """
        return pulumi.get(self, "password_rotation_in_seconds")

    @_builtins.property
    @pulumi.getter(name="requireLetter")
    def require_letter(self) -> Optional[_builtins.bool]:
        """
        require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
        """
        return pulumi.get(self, "require_letter")

    @_builtins.property
    @pulumi.getter(name="requireNumber")
    def require_number(self) -> Optional[_builtins.bool]:
        """
        require_number requires the password must contains at least one number.
        """
        return pulumi.get(self, "require_number")

    @_builtins.property
    @pulumi.getter(name="requireResetPasswordForFirstLogin")
    def require_reset_password_for_first_login(self) -> Optional[_builtins.bool]:
        """
        require*reset*password*for*first_login requires users to reset their password after the 1st login.
        """
        return pulumi.get(self, "require_reset_password_for_first_login")

    @_builtins.property
    @pulumi.getter(name="requireSpecialCharacter")
    def require_special_character(self) -> Optional[_builtins.bool]:
        """
        require*special*character requires the password must contains at least one special character.
        """
        return pulumi.get(self, "require_special_character")

    @_builtins.property
    @pulumi.getter(name="requireUppercaseLetter")
    def require_uppercase_letter(self) -> Optional[_builtins.bool]:
        """
        require*uppercase*letter requires the password must contains at least one upper case letter.
        """
        return pulumi.get(self, "require_uppercase_letter")


@pulumi.output_type
class GetSettingSemanticTypeResult(dict):
    def __init__(__self__, *,
                 algorithm: 'outputs.GetSettingSemanticTypeAlgorithmResult',
                 description: _builtins.str,
                 id: _builtins.str,
                 title: _builtins.str):
        """
        :param 'GetSettingSemanticTypeAlgorithmArgs' algorithm: The semantic type algorithm. Required.
        :param _builtins.str description: The semantic type description. Optional.
        :param _builtins.str id: The semantic type unique uuid.
        :param _builtins.str title: The semantic type title. Required.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> 'outputs.GetSettingSemanticTypeAlgorithmResult':
        """
        The semantic type algorithm. Required.
        """
        return pulumi.get(self, "algorithm")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The semantic type description. Optional.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The semantic type unique uuid.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The semantic type title. Required.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class GetSettingSemanticTypeAlgorithmResult(dict):
    def __init__(__self__, *,
                 full_mask: 'outputs.GetSettingSemanticTypeAlgorithmFullMaskResult',
                 inner_outer_mask: 'outputs.GetSettingSemanticTypeAlgorithmInnerOuterMaskResult',
                 md5_mask: 'outputs.GetSettingSemanticTypeAlgorithmMd5MaskResult',
                 range_mask: 'outputs.GetSettingSemanticTypeAlgorithmRangeMaskResult'):
        pulumi.set(__self__, "full_mask", full_mask)
        pulumi.set(__self__, "inner_outer_mask", inner_outer_mask)
        pulumi.set(__self__, "md5_mask", md5_mask)
        pulumi.set(__self__, "range_mask", range_mask)

    @_builtins.property
    @pulumi.getter(name="fullMask")
    def full_mask(self) -> 'outputs.GetSettingSemanticTypeAlgorithmFullMaskResult':
        return pulumi.get(self, "full_mask")

    @_builtins.property
    @pulumi.getter(name="innerOuterMask")
    def inner_outer_mask(self) -> 'outputs.GetSettingSemanticTypeAlgorithmInnerOuterMaskResult':
        return pulumi.get(self, "inner_outer_mask")

    @_builtins.property
    @pulumi.getter(name="md5Mask")
    def md5_mask(self) -> 'outputs.GetSettingSemanticTypeAlgorithmMd5MaskResult':
        return pulumi.get(self, "md5_mask")

    @_builtins.property
    @pulumi.getter(name="rangeMask")
    def range_mask(self) -> 'outputs.GetSettingSemanticTypeAlgorithmRangeMaskResult':
        return pulumi.get(self, "range_mask")


@pulumi.output_type
class GetSettingSemanticTypeAlgorithmFullMaskResult(dict):
    def __init__(__self__, *,
                 substitution: _builtins.str):
        """
        :param _builtins.str substitution: Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
        """
        pulumi.set(__self__, "substitution", substitution)

    @_builtins.property
    @pulumi.getter
    def substitution(self) -> _builtins.str:
        """
        Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
        """
        return pulumi.get(self, "substitution")


@pulumi.output_type
class GetSettingSemanticTypeAlgorithmInnerOuterMaskResult(dict):
    def __init__(__self__, *,
                 prefix_len: _builtins.int,
                 substitution: _builtins.str,
                 suffix_len: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.int prefix_len: The length of prefix.
        :param _builtins.str substitution: Substitution is the string used to replace the inner or outer substring.
        :param _builtins.int suffix_len: The length of suffix.
        :param _builtins.str type: INNER or OUTER.
        """
        pulumi.set(__self__, "prefix_len", prefix_len)
        pulumi.set(__self__, "substitution", substitution)
        pulumi.set(__self__, "suffix_len", suffix_len)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="prefixLen")
    def prefix_len(self) -> _builtins.int:
        """
        The length of prefix.
        """
        return pulumi.get(self, "prefix_len")

    @_builtins.property
    @pulumi.getter
    def substitution(self) -> _builtins.str:
        """
        Substitution is the string used to replace the inner or outer substring.
        """
        return pulumi.get(self, "substitution")

    @_builtins.property
    @pulumi.getter(name="suffixLen")
    def suffix_len(self) -> _builtins.int:
        """
        The length of suffix.
        """
        return pulumi.get(self, "suffix_len")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        INNER or OUTER.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSettingSemanticTypeAlgorithmMd5MaskResult(dict):
    def __init__(__self__, *,
                 salt: _builtins.str):
        """
        :param _builtins.str salt: Salt is the salt value to generate a different hash that with the word alone.
        """
        pulumi.set(__self__, "salt", salt)

    @_builtins.property
    @pulumi.getter
    def salt(self) -> _builtins.str:
        """
        Salt is the salt value to generate a different hash that with the word alone.
        """
        return pulumi.get(self, "salt")


@pulumi.output_type
class GetSettingSemanticTypeAlgorithmRangeMaskResult(dict):
    def __init__(__self__, *,
                 slices: Sequence['outputs.GetSettingSemanticTypeAlgorithmRangeMaskSliceResult']):
        pulumi.set(__self__, "slices", slices)

    @_builtins.property
    @pulumi.getter
    def slices(self) -> Sequence['outputs.GetSettingSemanticTypeAlgorithmRangeMaskSliceResult']:
        return pulumi.get(self, "slices")


@pulumi.output_type
class GetSettingSemanticTypeAlgorithmRangeMaskSliceResult(dict):
    def __init__(__self__, *,
                 end: _builtins.int,
                 start: _builtins.int,
                 substitution: _builtins.str):
        """
        :param _builtins.int end: End is the stop index of the original value, should be less than the length of the original value.
        :param _builtins.int start: Start is the start index of the original value, start from 0 and should be less than stop.
        :param _builtins.str substitution: Substitution is the string used to replace the OriginalValue[start:end).
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "substitution", substitution)

    @_builtins.property
    @pulumi.getter
    def end(self) -> _builtins.int:
        """
        End is the stop index of the original value, should be less than the length of the original value.
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.int:
        """
        Start is the start index of the original value, start from 0 and should be less than stop.
        """
        return pulumi.get(self, "start")

    @_builtins.property
    @pulumi.getter
    def substitution(self) -> _builtins.str:
        """
        Substitution is the string used to replace the OriginalValue[start:end).
        """
        return pulumi.get(self, "substitution")


@pulumi.output_type
class GetSettingSqlQueryRestrictionResult(dict):
    def __init__(__self__, *,
                 maximum_result_rows: Optional[_builtins.int] = None,
                 maximum_result_size: Optional[_builtins.int] = None):
        """
        :param _builtins.int maximum_result_rows: The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
        :param _builtins.int maximum_result_size: The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
        """
        if maximum_result_rows is not None:
            pulumi.set(__self__, "maximum_result_rows", maximum_result_rows)
        if maximum_result_size is not None:
            pulumi.set(__self__, "maximum_result_size", maximum_result_size)

    @_builtins.property
    @pulumi.getter(name="maximumResultRows")
    def maximum_result_rows(self) -> Optional[_builtins.int]:
        """
        The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
        """
        return pulumi.get(self, "maximum_result_rows")

    @_builtins.property
    @pulumi.getter(name="maximumResultSize")
    def maximum_result_size(self) -> Optional[_builtins.int]:
        """
        The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
        """
        return pulumi.get(self, "maximum_result_size")


@pulumi.output_type
class GetSettingWorkspaceProfileResult(dict):
    def __init__(__self__, *,
                 announcement: Optional['outputs.GetSettingWorkspaceProfileAnnouncementResult'] = None,
                 database_change_mode: Optional[_builtins.str] = None,
                 disallow_password_signin: Optional[_builtins.bool] = None,
                 disallow_signup: Optional[_builtins.bool] = None,
                 domains: Optional[Sequence[_builtins.str]] = None,
                 enforce_identity_domain: Optional[_builtins.bool] = None,
                 external_url: Optional[_builtins.str] = None,
                 maximum_role_expiration_in_seconds: Optional[_builtins.int] = None,
                 token_duration_in_seconds: Optional[_builtins.int] = None):
        """
        :param 'GetSettingWorkspaceProfileAnnouncementArgs' announcement: Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
        :param _builtins.str database_change_mode: The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
        :param _builtins.bool disallow_password_signin: Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
        :param _builtins.bool disallow_signup: Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
        :param Sequence[_builtins.str] domains: The workspace domain, e.g. bytebase.com. Required for the group
        :param _builtins.bool enforce_identity_domain: Only user and group from the domains can be created and login.
        :param _builtins.str external_url: The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
        :param _builtins.int maximum_role_expiration_in_seconds: The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
        :param _builtins.int token_duration_in_seconds: The duration for login token in seconds. The duration should be at least 3600 (one hour).
        """
        if announcement is not None:
            pulumi.set(__self__, "announcement", announcement)
        if database_change_mode is not None:
            pulumi.set(__self__, "database_change_mode", database_change_mode)
        if disallow_password_signin is not None:
            pulumi.set(__self__, "disallow_password_signin", disallow_password_signin)
        if disallow_signup is not None:
            pulumi.set(__self__, "disallow_signup", disallow_signup)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if enforce_identity_domain is not None:
            pulumi.set(__self__, "enforce_identity_domain", enforce_identity_domain)
        if external_url is not None:
            pulumi.set(__self__, "external_url", external_url)
        if maximum_role_expiration_in_seconds is not None:
            pulumi.set(__self__, "maximum_role_expiration_in_seconds", maximum_role_expiration_in_seconds)
        if token_duration_in_seconds is not None:
            pulumi.set(__self__, "token_duration_in_seconds", token_duration_in_seconds)

    @_builtins.property
    @pulumi.getter
    def announcement(self) -> Optional['outputs.GetSettingWorkspaceProfileAnnouncementResult']:
        """
        Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
        """
        return pulumi.get(self, "announcement")

    @_builtins.property
    @pulumi.getter(name="databaseChangeMode")
    def database_change_mode(self) -> Optional[_builtins.str]:
        """
        The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
        """
        return pulumi.get(self, "database_change_mode")

    @_builtins.property
    @pulumi.getter(name="disallowPasswordSignin")
    def disallow_password_signin(self) -> Optional[_builtins.bool]:
        """
        Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
        """
        return pulumi.get(self, "disallow_password_signin")

    @_builtins.property
    @pulumi.getter(name="disallowSignup")
    def disallow_signup(self) -> Optional[_builtins.bool]:
        """
        Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
        """
        return pulumi.get(self, "disallow_signup")

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        The workspace domain, e.g. bytebase.com. Required for the group
        """
        return pulumi.get(self, "domains")

    @_builtins.property
    @pulumi.getter(name="enforceIdentityDomain")
    def enforce_identity_domain(self) -> Optional[_builtins.bool]:
        """
        Only user and group from the domains can be created and login.
        """
        return pulumi.get(self, "enforce_identity_domain")

    @_builtins.property
    @pulumi.getter(name="externalUrl")
    def external_url(self) -> Optional[_builtins.str]:
        """
        The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
        """
        return pulumi.get(self, "external_url")

    @_builtins.property
    @pulumi.getter(name="maximumRoleExpirationInSeconds")
    def maximum_role_expiration_in_seconds(self) -> Optional[_builtins.int]:
        """
        The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
        """
        return pulumi.get(self, "maximum_role_expiration_in_seconds")

    @_builtins.property
    @pulumi.getter(name="tokenDurationInSeconds")
    def token_duration_in_seconds(self) -> Optional[_builtins.int]:
        """
        The duration for login token in seconds. The duration should be at least 3600 (one hour).
        """
        return pulumi.get(self, "token_duration_in_seconds")


@pulumi.output_type
class GetSettingWorkspaceProfileAnnouncementResult(dict):
    def __init__(__self__, *,
                 level: _builtins.str,
                 text: _builtins.str,
                 link: Optional[_builtins.str] = None):
        """
        :param _builtins.str level: The alert level of announcement
        :param _builtins.str text: The text of announcement. Leave it as empty string can clear the announcement
        :param _builtins.str link: The optional link, user can follow the link to check extra details
        """
        pulumi.set(__self__, "level", level)
        pulumi.set(__self__, "text", text)
        if link is not None:
            pulumi.set(__self__, "link", link)

    @_builtins.property
    @pulumi.getter
    def level(self) -> _builtins.str:
        """
        The alert level of announcement
        """
        return pulumi.get(self, "level")

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        The text of announcement. Leave it as empty string can clear the announcement
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter
    def link(self) -> Optional[_builtins.str]:
        """
        The optional link, user can follow the link to check extra details
        """
        return pulumi.get(self, "link")


