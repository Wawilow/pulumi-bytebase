# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'GetListProjectResult',
    'GetListProjectWebhookResult',
]

@pulumi.output_type
class GetListProjectResult(dict):
    def __init__(__self__, *,
                 allow_modify_statement: _builtins.bool,
                 allow_self_approval: _builtins.bool,
                 auto_enable_backup: _builtins.bool,
                 auto_resolve_issue: _builtins.bool,
                 databases: Sequence[_builtins.str],
                 enforce_issue_title: _builtins.bool,
                 name: _builtins.str,
                 postgres_database_tenant_mode: _builtins.bool,
                 resource_id: _builtins.str,
                 skip_backup_errors: _builtins.bool,
                 title: _builtins.str,
                 webhooks: Sequence['outputs.GetListProjectWebhookResult']):
        """
        :param _builtins.bool allow_modify_statement: Allow modifying statement after issue is created.
        :param _builtins.bool allow_self_approval: Whether to allow the issue creator to self-approve the issue.
        :param _builtins.bool auto_enable_backup: Whether to automatically enable backup.
        :param _builtins.bool auto_resolve_issue: Enable auto resolve issue.
        :param Sequence[_builtins.str] databases: The databases full name in the resource.
        :param _builtins.bool enforce_issue_title: Enforce issue title created by user instead of generated by Bytebase.
        :param _builtins.str name: The project full name in projects/{resource id} format.
        :param _builtins.bool postgres_database_tenant_mode: Whether to enable the database tenant mode for PostgreSQL. If enabled, the issue will be created with the pre-appended "set role <db_owner>" statement.
        :param _builtins.str resource_id: The project unique resource id.
        :param _builtins.bool skip_backup_errors: Whether to skip backup errors and continue the data migration.
        :param _builtins.str title: The project title.
        :param Sequence['GetListProjectWebhookArgs'] webhooks: The webhooks in the project.
        """
        pulumi.set(__self__, "allow_modify_statement", allow_modify_statement)
        pulumi.set(__self__, "allow_self_approval", allow_self_approval)
        pulumi.set(__self__, "auto_enable_backup", auto_enable_backup)
        pulumi.set(__self__, "auto_resolve_issue", auto_resolve_issue)
        pulumi.set(__self__, "databases", databases)
        pulumi.set(__self__, "enforce_issue_title", enforce_issue_title)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "postgres_database_tenant_mode", postgres_database_tenant_mode)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "skip_backup_errors", skip_backup_errors)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "webhooks", webhooks)

    @_builtins.property
    @pulumi.getter(name="allowModifyStatement")
    def allow_modify_statement(self) -> _builtins.bool:
        """
        Allow modifying statement after issue is created.
        """
        return pulumi.get(self, "allow_modify_statement")

    @_builtins.property
    @pulumi.getter(name="allowSelfApproval")
    def allow_self_approval(self) -> _builtins.bool:
        """
        Whether to allow the issue creator to self-approve the issue.
        """
        return pulumi.get(self, "allow_self_approval")

    @_builtins.property
    @pulumi.getter(name="autoEnableBackup")
    def auto_enable_backup(self) -> _builtins.bool:
        """
        Whether to automatically enable backup.
        """
        return pulumi.get(self, "auto_enable_backup")

    @_builtins.property
    @pulumi.getter(name="autoResolveIssue")
    def auto_resolve_issue(self) -> _builtins.bool:
        """
        Enable auto resolve issue.
        """
        return pulumi.get(self, "auto_resolve_issue")

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Sequence[_builtins.str]:
        """
        The databases full name in the resource.
        """
        return pulumi.get(self, "databases")

    @_builtins.property
    @pulumi.getter(name="enforceIssueTitle")
    def enforce_issue_title(self) -> _builtins.bool:
        """
        Enforce issue title created by user instead of generated by Bytebase.
        """
        return pulumi.get(self, "enforce_issue_title")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The project full name in projects/{resource id} format.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="postgresDatabaseTenantMode")
    def postgres_database_tenant_mode(self) -> _builtins.bool:
        """
        Whether to enable the database tenant mode for PostgreSQL. If enabled, the issue will be created with the pre-appended "set role <db_owner>" statement.
        """
        return pulumi.get(self, "postgres_database_tenant_mode")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        The project unique resource id.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="skipBackupErrors")
    def skip_backup_errors(self) -> _builtins.bool:
        """
        Whether to skip backup errors and continue the data migration.
        """
        return pulumi.get(self, "skip_backup_errors")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The project title.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def webhooks(self) -> Sequence['outputs.GetListProjectWebhookResult']:
        """
        The webhooks in the project.
        """
        return pulumi.get(self, "webhooks")


@pulumi.output_type
class GetListProjectWebhookResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 notification_types: Sequence[_builtins.str],
                 title: _builtins.str,
                 type: _builtins.str,
                 url: _builtins.str,
                 direct_message: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The webhook full name in projects/{resource id}/webhooks/{id} format.
        :param Sequence[_builtins.str] notification_types: notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
        :param _builtins.str title: The webhook title
        :param _builtins.str type: The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
        :param _builtins.str url: The webhook URL
        :param _builtins.bool direct_message: If direct_message is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notification_types", notification_types)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        if direct_message is not None:
            pulumi.set(__self__, "direct_message", direct_message)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The webhook full name in projects/{resource id}/webhooks/{id} format.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="notificationTypes")
    def notification_types(self) -> Sequence[_builtins.str]:
        """
        notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
        """
        return pulumi.get(self, "notification_types")

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The webhook title
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The webhook URL
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="directMessage")
    def direct_message(self) -> Optional[_builtins.bool]:
        """
        If direct_message is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
        """
        return pulumi.get(self, "direct_message")


