// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DatabaseCatalog {
    schemas: outputs.DatabaseCatalogSchema[];
}

export interface DatabaseCatalogSchema {
    name?: string;
    tables: outputs.DatabaseCatalogSchemaTable[];
}

export interface DatabaseCatalogSchemaTable {
    /**
     * The classification id
     */
    classification: string;
    columns: outputs.DatabaseCatalogSchemaTableColumn[];
    name: string;
}

export interface DatabaseCatalogSchemaTableColumn {
    /**
     * The classification id
     */
    classification: string;
    labels?: {[key: string]: string};
    name: string;
    /**
     * The semantic type id
     */
    semanticType: string;
}

export interface GetDatabaseCatalog {
    schemas: outputs.GetDatabaseCatalogSchema[];
}

export interface GetDatabaseCatalogSchema {
    name: string;
    tables: outputs.GetDatabaseCatalogSchemaTable[];
}

export interface GetDatabaseCatalogSchemaTable {
    /**
     * The classification id
     */
    classification: string;
    columns: outputs.GetDatabaseCatalogSchemaTableColumn[];
    name: string;
}

export interface GetDatabaseCatalogSchemaTableColumn {
    /**
     * The classification id
     */
    classification: string;
    /**
     * The deployment and policy control labels.
     */
    labels: {[key: string]: string};
    /**
     * The database full name in instances/{instance}/databases/{database} format
     */
    name: string;
    /**
     * The semantic type id
     */
    semanticType: string;
}

export interface GetGroupMember {
    /**
     * The member in users/{email} format.
     */
    member: string;
    /**
     * The member's role in the group.
     */
    role: string;
}

export interface GetInstanceDataSource {
    /**
     * The database for the instance, you can set this if the engine type is POSTGRES.
     */
    database: string;
    /**
     * The external secret to get the database password. Learn more: https://www.bytebase.com/docs/get-started/instance/#use-external-secret-manager
     */
    externalSecrets: outputs.GetInstanceDataSourceExternalSecret[];
    /**
     * Host or socket for your instance, or the account name if the instance type is Snowflake.
     */
    host: string;
    /**
     * The unique data source id in this instance.
     */
    id: string;
    /**
     * The connection user password used by Bytebase to perform DDL and DML operations.
     */
    password: string;
    /**
     * The port for your instance.
     */
    port: string;
    /**
     * The CA certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB, CLICKHOUSE or COCKROACHDB.
     */
    sslCa: string;
    /**
     * The client certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB, CLICKHOUSE or COCKROACHDB.
     */
    sslCert: string;
    /**
     * The client key. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB, CLICKHOUSE or COCKROACHDB.
     */
    sslKey: string;
    /**
     * The data source type. Should be ADMIN or READ_ONLY.
     */
    type: string;
    /**
     * Enable SSL connection. Required to use SSL certificates.
     */
    useSsl: boolean;
    /**
     * The connection user name used by Bytebase to perform DDL and DML operations.
     */
    username: string;
}

export interface GetInstanceDataSourceExternalSecret {
    /**
     * The AWS Secrets Manager to get the database password. Reference doc https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html
     */
    awsSecretsManagers: outputs.GetInstanceDataSourceExternalSecretAwsSecretsManager[];
    /**
     * The GCP Secret Manager to get the database password. Reference doc https://cloud.google.com/secret-manager/docs
     */
    gcpSecretManagers: outputs.GetInstanceDataSourceExternalSecretGcpSecretManager[];
    vaults: outputs.GetInstanceDataSourceExternalSecretVault[];
}

export interface GetInstanceDataSourceExternalSecretAwsSecretsManager {
    /**
     * The key name for the password.
     */
    passwordKeyName: string;
    /**
     * The secret name to store the password.
     */
    secretName: string;
}

export interface GetInstanceDataSourceExternalSecretGcpSecretManager {
    /**
     * The secret name should be like "projects/{project-id}/secrets/{secret-id}".
     */
    secretName: string;
}

export interface GetInstanceDataSourceExternalSecretVault {
    /**
     * The Vault app role to get the password.
     */
    appRoles: outputs.GetInstanceDataSourceExternalSecretVaultAppRole[];
    /**
     * The name for secret engine.
     */
    engineName: string;
    /**
     * The key name for the password.
     */
    passwordKeyName: string;
    /**
     * The secret name in the engine to store the password.
     */
    secretName: string;
    token: string;
    /**
     * The Vault URL.
     */
    url: string;
}

export interface GetInstanceDataSourceExternalSecretVaultAppRole {
    /**
     * The app role id.
     */
    roleId: string;
    /**
     * The secret id for the role without ttl.
     */
    secret: string;
    /**
     * The secret id type, can be PLAIN (plain text for the secret) or ENVIRONMENT (envirionment name for the secret).
     */
    secretType: string;
}

export interface GetPolicyDataSourceQueryPolicy {
    /**
     * Disallow running DDL statements in the SQL editor.
     */
    disallowDdl?: boolean;
    /**
     * Disallow running DML statements in the SQL editor.
     */
    disallowDml?: boolean;
    /**
     * RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
     */
    restriction?: string;
}

export interface GetPolicyDisableCopyDataPolicy {
    /**
     * Restrict data copying
     */
    enable: boolean;
}

export interface GetPolicyGlobalMaskingPolicy {
    rules: outputs.GetPolicyGlobalMaskingPolicyRule[];
}

export interface GetPolicyGlobalMaskingPolicyRule {
    /**
     * The condition expression
     */
    condition: string;
    /**
     * The unique rule id
     */
    id: string;
    /**
     * The semantic type id
     */
    semanticType: string;
    /**
     * The title for the rule
     */
    title?: string;
}

export interface GetPolicyMaskingExceptionPolicy {
    exceptions: outputs.GetPolicyMaskingExceptionPolicyException[];
}

export interface GetPolicyMaskingExceptionPolicyException {
    action: string;
    column: string;
    /**
     * The database full name in instances/{instance resource id}/databases/{database name} format
     */
    database: string;
    /**
     * The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
     */
    expireTimestamp: string;
    /**
     * The member in user:{email} or group:{email} format.
     */
    member: string;
    /**
     * The reason for the masking exemption
     */
    reason?: string;
    schema: string;
    table: string;
}

export interface GetPolicyRolloutPolicy {
    /**
     * If all check pass, the change will be rolled out and executed automatically.
     */
    automatic?: boolean;
    /**
     * If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
     */
    roles?: string[];
}

export interface GetProjectWebhook {
    /**
     * If directMessage is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
     */
    directMessage?: boolean;
    /**
     * The webhook full name in projects/{resource id}/webhooks/{id} format.
     */
    name: string;
    /**
     * notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
     */
    notificationTypes: string[];
    /**
     * The webhook title
     */
    title: string;
    /**
     * The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
     */
    type: string;
    /**
     * The webhook URL
     */
    url: string;
}

export interface GetSettingApprovalFlow {
    rules: outputs.GetSettingApprovalFlowRule[];
}

export interface GetSettingApprovalFlowRule {
    /**
     * Match any condition will trigger this approval flow.
     */
    conditions: outputs.GetSettingApprovalFlowRuleCondition[];
    flows: outputs.GetSettingApprovalFlowRuleFlow[];
}

export interface GetSettingApprovalFlowRuleCondition {
    level: string;
    source: string;
}

export interface GetSettingApprovalFlowRuleFlow {
    description: string;
    /**
     * Approval flow following the step order.
     */
    steps: outputs.GetSettingApprovalFlowRuleFlowStep[];
    title: string;
}

export interface GetSettingApprovalFlowRuleFlowStep {
    /**
     * The role require to review in this step
     */
    role: string;
}

export interface GetSettingClassification {
    /**
     * If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
     */
    classificationFromConfig: boolean;
    classifications: outputs.GetSettingClassificationClassification[];
    /**
     * The classification unique uuid.
     */
    id: string;
    levels: outputs.GetSettingClassificationLevel[];
    /**
     * The classification title. Optional.
     */
    title: string;
}

export interface GetSettingClassificationClassification {
    /**
     * The classification description.
     */
    description: string;
    /**
     * The classification unique id, must in {number}-{number} format.
     */
    id: string;
    /**
     * The classification level id.
     */
    level: string;
    /**
     * The classification title.
     */
    title: string;
}

export interface GetSettingClassificationLevel {
    /**
     * The classification level description.
     */
    description: string;
    /**
     * The classification level unique uuid.
     */
    id: string;
    /**
     * The classification level title.
     */
    title: string;
}

export interface GetSettingEnvironmentSetting {
    environments: outputs.GetSettingEnvironmentSettingEnvironment[];
}

export interface GetSettingEnvironmentSettingEnvironment {
    /**
     * The environment color.
     */
    color?: string;
    /**
     * The environment unique id.
     */
    id: string;
    /**
     * The environment readonly name in environments/{id} format.
     */
    name: string;
    /**
     * The environment is protected or not.
     */
    protected?: boolean;
    /**
     * The environment display name.
     */
    title: string;
}

export interface GetSettingPasswordRestriction {
    /**
     * min_length is the minimum length for password, should no less than 8.
     */
    minLength?: number;
    /**
     * password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
     */
    passwordRotationInSeconds?: number;
    /**
     * require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
     */
    requireLetter?: boolean;
    /**
     * require_number requires the password must contains at least one number.
     */
    requireNumber?: boolean;
    /**
     * require*reset*password*for*first_login requires users to reset their password after the 1st login.
     */
    requireResetPasswordForFirstLogin?: boolean;
    /**
     * require*special*character requires the password must contains at least one special character.
     */
    requireSpecialCharacter?: boolean;
    /**
     * require*uppercase*letter requires the password must contains at least one upper case letter.
     */
    requireUppercaseLetter?: boolean;
}

export interface GetSettingSemanticType {
    /**
     * The semantic type algorithm. Required.
     */
    algorithm: outputs.GetSettingSemanticTypeAlgorithm;
    /**
     * The semantic type description. Optional.
     */
    description: string;
    /**
     * The semantic type unique uuid.
     */
    id: string;
    /**
     * The semantic type title. Required.
     */
    title: string;
}

export interface GetSettingSemanticTypeAlgorithm {
    fullMask: outputs.GetSettingSemanticTypeAlgorithmFullMask;
    innerOuterMask: outputs.GetSettingSemanticTypeAlgorithmInnerOuterMask;
    md5Mask: outputs.GetSettingSemanticTypeAlgorithmMd5Mask;
    rangeMask: outputs.GetSettingSemanticTypeAlgorithmRangeMask;
}

export interface GetSettingSemanticTypeAlgorithmFullMask {
    /**
     * Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
     */
    substitution: string;
}

export interface GetSettingSemanticTypeAlgorithmInnerOuterMask {
    /**
     * The length of prefix.
     */
    prefixLen: number;
    /**
     * Substitution is the string used to replace the inner or outer substring.
     */
    substitution: string;
    /**
     * The length of suffix.
     */
    suffixLen: number;
    /**
     * INNER or OUTER.
     */
    type: string;
}

export interface GetSettingSemanticTypeAlgorithmMd5Mask {
    /**
     * Salt is the salt value to generate a different hash that with the word alone.
     */
    salt: string;
}

export interface GetSettingSemanticTypeAlgorithmRangeMask {
    slices: outputs.GetSettingSemanticTypeAlgorithmRangeMaskSlice[];
}

export interface GetSettingSemanticTypeAlgorithmRangeMaskSlice {
    /**
     * End is the stop index of the original value, should be less than the length of the original value.
     */
    end: number;
    /**
     * Start is the start index of the original value, start from 0 and should be less than stop.
     */
    start: number;
    /**
     * Substitution is the string used to replace the OriginalValue[start:end).
     */
    substitution: string;
}

export interface GetSettingSqlQueryRestriction {
    /**
     * The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
     */
    maximumResultRows?: number;
    /**
     * The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
     */
    maximumResultSize?: number;
}

export interface GetSettingWorkspaceProfile {
    /**
     * Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
     */
    announcement?: outputs.GetSettingWorkspaceProfileAnnouncement;
    /**
     * The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
     */
    databaseChangeMode?: string;
    /**
     * Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
     */
    disallowPasswordSignin?: boolean;
    /**
     * Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
     */
    disallowSignup?: boolean;
    /**
     * The workspace domain, e.g. bytebase.com. Required for the group
     */
    domains?: string[];
    /**
     * Only user and group from the domains can be created and login.
     */
    enforceIdentityDomain?: boolean;
    /**
     * The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
     */
    externalUrl?: string;
    /**
     * The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
     */
    maximumRoleExpirationInSeconds?: number;
    /**
     * The duration for login token in seconds. The duration should be at least 3600 (one hour).
     */
    tokenDurationInSeconds?: number;
}

export interface GetSettingWorkspaceProfileAnnouncement {
    /**
     * The alert level of announcement
     */
    level: string;
    /**
     * The optional link, user can follow the link to check extra details
     */
    link?: string;
    /**
     * The text of announcement. Leave it as empty string can clear the announcement
     */
    text: string;
}

export interface GroupMember {
    /**
     * The member in users/{email} format.
     */
    member: string;
    /**
     * The member's role in the group, should be OWNER or MEMBER.
     */
    role: string;
}

export interface InstanceDataSource {
    /**
     * The database for the instance, you can set this if the engine type is POSTGRES.
     */
    database?: string;
    /**
     * The external secret to get the database password. Learn more: https://www.bytebase.com/docs/get-started/instance/#use-external-secret-manager
     */
    externalSecret?: outputs.InstanceDataSourceExternalSecret;
    /**
     * Host or socket for your instance, or the account name if the instance type is Snowflake.
     */
    host: string;
    /**
     * The unique data source id in this instance.
     */
    id: string;
    /**
     * The connection user password used by Bytebase to perform DDL and DML operations.
     */
    password: string;
    /**
     * The port for your instance.
     */
    port: string;
    /**
     * The CA certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
     */
    sslCa: string;
    /**
     * The client certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
     */
    sslCert: string;
    /**
     * The client key. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
     */
    sslKey: string;
    /**
     * The data source type. Should be ADMIN or READ_ONLY.
     */
    type: string;
    /**
     * Enable SSL connection. Required to use SSL certificates.
     */
    useSsl?: boolean;
    /**
     * The connection user name used by Bytebase to perform DDL and DML operations.
     */
    username?: string;
}

export interface InstanceDataSourceExternalSecret {
    /**
     * The AWS Secrets Manager to get the database password. Reference doc https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html
     */
    awsSecretsManager?: outputs.InstanceDataSourceExternalSecretAwsSecretsManager;
    /**
     * The GCP Secret Manager to get the database password. Reference doc https://cloud.google.com/secret-manager/docs
     */
    gcpSecretManager?: outputs.InstanceDataSourceExternalSecretGcpSecretManager;
    vault?: outputs.InstanceDataSourceExternalSecretVault;
}

export interface InstanceDataSourceExternalSecretAwsSecretsManager {
    /**
     * The key name for the password.
     */
    passwordKeyName: string;
    /**
     * The secret name to store the password.
     */
    secretName: string;
}

export interface InstanceDataSourceExternalSecretGcpSecretManager {
    /**
     * The secret name should be like "projects/{project-id}/secrets/{secret-id}".
     */
    secretName: string;
}

export interface InstanceDataSourceExternalSecretVault {
    /**
     * The Vault app role to get the password.
     */
    appRole?: outputs.InstanceDataSourceExternalSecretVaultAppRole;
    /**
     * The name for secret engine.
     */
    engineName: string;
    /**
     * The key name for the password.
     */
    passwordKeyName: string;
    /**
     * The secret name in the engine to store the password.
     */
    secretName: string;
    token?: string;
    /**
     * The Vault URL.
     */
    url: string;
}

export interface InstanceDataSourceExternalSecretVaultAppRole {
    /**
     * The app role id.
     */
    roleId: string;
    /**
     * The secret id for the role without ttl.
     */
    secret: string;
    /**
     * The secret id type, can be PLAIN (plain text for the secret) or ENVIRONMENT (envirionment name for the secret).
     */
    secretType: string;
}

export interface PolicyDataSourceQueryPolicy {
    /**
     * Disallow running DDL statements in the SQL editor.
     */
    disallowDdl?: boolean;
    /**
     * Disallow running DML statements in the SQL editor.
     */
    disallowDml?: boolean;
    /**
     * RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
     */
    restriction?: string;
}

export interface PolicyDisableCopyDataPolicy {
    /**
     * Restrict data copying
     */
    enable: boolean;
}

export interface PolicyGlobalMaskingPolicy {
    rules?: outputs.PolicyGlobalMaskingPolicyRule[];
}

export interface PolicyGlobalMaskingPolicyRule {
    /**
     * The condition expression
     */
    condition: string;
    /**
     * The unique rule id
     */
    id: string;
    /**
     * The semantic type id
     */
    semanticType: string;
    /**
     * The title for the rule
     */
    title?: string;
}

export interface PolicyMaskingExceptionPolicy {
    exceptions?: outputs.PolicyMaskingExceptionPolicyException[];
}

export interface PolicyMaskingExceptionPolicyException {
    action: string;
    column?: string;
    /**
     * The database full name in instances/{instance resource id}/databases/{database name} format
     */
    database: string;
    /**
     * The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
     */
    expireTimestamp?: string;
    /**
     * The member in user:{email} or group:{email} format.
     */
    member: string;
    /**
     * The reason for the masking exemption
     */
    reason?: string;
    schema?: string;
    table?: string;
}

export interface PolicyRolloutPolicy {
    /**
     * If all check pass, the change will be rolled out and executed automatically.
     */
    automatic?: boolean;
    /**
     * If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
     */
    roles?: string[];
}

export interface ProjectWebhook {
    /**
     * If directMessage is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
     */
    directMessage?: boolean;
    /**
     * The webhook full name in projects/{resource id}/webhooks/{id} format.
     */
    name: string;
    /**
     * notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
     */
    notificationTypes: string[];
    /**
     * The webhook title
     */
    title: string;
    /**
     * The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
     */
    type: string;
    /**
     * The webhook URL
     */
    url: string;
}

export interface SettingApprovalFlow {
    rules: outputs.SettingApprovalFlowRule[];
}

export interface SettingApprovalFlowRule {
    /**
     * Match any condition will trigger this approval flow.
     */
    conditions?: outputs.SettingApprovalFlowRuleCondition[];
    flows: outputs.SettingApprovalFlowRuleFlow[];
}

export interface SettingApprovalFlowRuleCondition {
    level?: string;
    source?: string;
}

export interface SettingApprovalFlowRuleFlow {
    description?: string;
    /**
     * Approval flow following the step order.
     */
    steps: outputs.SettingApprovalFlowRuleFlowStep[];
    title: string;
}

export interface SettingApprovalFlowRuleFlowStep {
    /**
     * The role require to review in this step
     */
    role: string;
}

export interface SettingClassification {
    /**
     * If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
     */
    classificationFromConfig?: boolean;
    classifications: outputs.SettingClassificationClassification[];
    /**
     * The classification unique uuid.
     */
    id: string;
    levels: outputs.SettingClassificationLevel[];
    /**
     * The classification title. Optional.
     */
    title: string;
}

export interface SettingClassificationClassification {
    /**
     * The classification description.
     */
    description?: string;
    /**
     * The classification unique id, must in {number}-{number} format.
     */
    id: string;
    /**
     * The classification level id.
     */
    level?: string;
    /**
     * The classification title.
     */
    title: string;
}

export interface SettingClassificationLevel {
    /**
     * The classification level description.
     */
    description?: string;
    /**
     * The classification level unique uuid.
     */
    id: string;
    /**
     * The classification level title.
     */
    title: string;
}

export interface SettingEnvironmentSetting {
    environments: outputs.SettingEnvironmentSettingEnvironment[];
}

export interface SettingEnvironmentSettingEnvironment {
    /**
     * The environment color.
     */
    color?: string;
    /**
     * The environment unique id.
     */
    id: string;
    /**
     * The environment readonly name in environments/{id} format.
     */
    name: string;
    /**
     * The environment is protected or not.
     */
    protected?: boolean;
    /**
     * The environment display name.
     */
    title: string;
}

export interface SettingPasswordRestriction {
    /**
     * min_length is the minimum length for password, should no less than 8.
     */
    minLength?: number;
    /**
     * password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
     */
    passwordRotationInSeconds?: number;
    /**
     * require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
     */
    requireLetter?: boolean;
    /**
     * require_number requires the password must contains at least one number.
     */
    requireNumber?: boolean;
    /**
     * require*reset*password*for*first_login requires users to reset their password after the 1st login.
     */
    requireResetPasswordForFirstLogin?: boolean;
    /**
     * require*special*character requires the password must contains at least one special character.
     */
    requireSpecialCharacter?: boolean;
    /**
     * require*uppercase*letter requires the password must contains at least one upper case letter.
     */
    requireUppercaseLetter?: boolean;
}

export interface SettingSemanticType {
    /**
     * The semantic type algorithm. Required.
     */
    algorithm?: outputs.SettingSemanticTypeAlgorithm;
    /**
     * The semantic type description. Optional.
     */
    description?: string;
    /**
     * The semantic type unique uuid.
     */
    id: string;
    /**
     * The semantic type title. Required.
     */
    title: string;
}

export interface SettingSemanticTypeAlgorithm {
    fullMask?: outputs.SettingSemanticTypeAlgorithmFullMask;
    innerOuterMask?: outputs.SettingSemanticTypeAlgorithmInnerOuterMask;
    md5Mask?: outputs.SettingSemanticTypeAlgorithmMd5Mask;
    rangeMask?: outputs.SettingSemanticTypeAlgorithmRangeMask;
}

export interface SettingSemanticTypeAlgorithmFullMask {
    /**
     * Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
     */
    substitution: string;
}

export interface SettingSemanticTypeAlgorithmInnerOuterMask {
    /**
     * The length of prefix.
     */
    prefixLen: number;
    /**
     * Substitution is the string used to replace the inner or outer substring.
     */
    substitution: string;
    /**
     * The length of suffix.
     */
    suffixLen: number;
    /**
     * INNER or OUTER.
     */
    type: string;
}

export interface SettingSemanticTypeAlgorithmMd5Mask {
    /**
     * Salt is the salt value to generate a different hash that with the word alone.
     */
    salt: string;
}

export interface SettingSemanticTypeAlgorithmRangeMask {
    slices?: outputs.SettingSemanticTypeAlgorithmRangeMaskSlice[];
}

export interface SettingSemanticTypeAlgorithmRangeMaskSlice {
    /**
     * End is the stop index of the original value, should be less than the length of the original value.
     */
    end: number;
    /**
     * Start is the start index of the original value, start from 0 and should be less than stop.
     */
    start: number;
    /**
     * Substitution is the string used to replace the OriginalValue[start:end).
     */
    substitution: string;
}

export interface SettingSqlQueryRestriction {
    /**
     * The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
     */
    maximumResultRows?: number;
    /**
     * The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
     */
    maximumResultSize?: number;
}

export interface SettingWorkspaceProfile {
    /**
     * Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
     */
    announcement?: outputs.SettingWorkspaceProfileAnnouncement;
    /**
     * The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
     */
    databaseChangeMode?: string;
    /**
     * Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
     */
    disallowPasswordSignin?: boolean;
    /**
     * Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
     */
    disallowSignup?: boolean;
    /**
     * The workspace domain, e.g. bytebase.com. Required for the group
     */
    domains?: string[];
    /**
     * Only user and group from the domains can be created and login.
     */
    enforceIdentityDomain?: boolean;
    /**
     * The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
     */
    externalUrl?: string;
    /**
     * The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
     */
    maximumRoleExpirationInSeconds?: number;
    /**
     * The duration for login token in seconds. The duration should be at least 3600 (one hour).
     */
    tokenDurationInSeconds?: number;
}

export interface SettingWorkspaceProfileAnnouncement {
    /**
     * The alert level of announcement
     */
    level: string;
    /**
     * The optional link, user can follow the link to check extra details
     */
    link?: string;
    /**
     * The text of announcement. Leave it as empty string can clear the announcement
     */
    text: string;
}

export namespace Database {
    export interface GetListDatabase {
        /**
         * The database environment, will follow the instance environment by default
         */
        environment: string;
        /**
         * The deployment and policy control labels.
         */
        labels: {[key: string]: string};
        /**
         * The database full name in instances/{instance}/databases/{database} format
         */
        name: string;
        /**
         * The project full name for the database in projects/{project} format.
         */
        project: string;
        /**
         * The version of database schema.
         */
        schemaVersion: string;
        /**
         * The existence of a database.
         */
        state: string;
        /**
         * The latest synchronization time.
         */
        successfulSyncTime: string;
    }

}

export namespace DatabaseGroup {
    export interface GetListDatabaseGroup {
        /**
         * The database group condition.
         */
        condition: string;
        /**
         * The database group fullname in projects/{id}/databaseGroups/{id} format.
         */
        name: string;
        /**
         * The database group title.
         */
        title: string;
    }

}

export namespace Group {
    export interface GetListGroup {
        /**
         * The group description.
         */
        description: string;
        /**
         * The members in the group.
         */
        members: outputs.Group.GetListGroupMember[];
        /**
         * The group name in groups/{email} format.
         */
        name: string;
        /**
         * Source means where the group comes from. For now we support Entra ID SCIM sync, so the source could be Entra ID.
         */
        source: string;
        /**
         * The group title.
         */
        title: string;
    }

    export interface GetListGroupMember {
        /**
         * The member in users/{email} format.
         */
        member: string;
        /**
         * The member's role in the group.
         */
        role: string;
    }

}

export namespace Iam {
    export interface GetPolicyIamPolicy {
        /**
         * The binding in the IAM policy.
         */
        bindings?: outputs.Iam.GetPolicyIamPolicyBinding[];
    }

    export interface GetPolicyIamPolicyBinding {
        /**
         * Match the condition limit.
         */
        conditions?: outputs.Iam.GetPolicyIamPolicyBindingCondition[];
        /**
         * A set of memebers. The value can be "allUsers", "user:{email}" or "group:{email}".
         */
        members?: string[];
        /**
         * The role full name in roles/{id} format.
         */
        role?: string;
    }

    export interface GetPolicyIamPolicyBindingCondition {
        /**
         * The accessible database full name in instances/{instance resource id}/databases/{database name} format
         */
        database?: string;
        /**
         * The expiration timestamp in YYYY-MM-DDThh:mm:ssZ format
         */
        expireTimestamp?: string;
        /**
         * The export row limit for exporter role
         */
        rowLimit?: number;
        /**
         * The accessible schema in the database
         */
        schema?: string;
        /**
         * The accessible table list
         */
        tables?: string[];
    }

    export interface PolicyIamPolicy {
        /**
         * The binding in the IAM policy.
         */
        bindings?: outputs.Iam.PolicyIamPolicyBinding[];
    }

    export interface PolicyIamPolicyBinding {
        /**
         * Match the condition limit.
         */
        conditions?: outputs.Iam.PolicyIamPolicyBindingCondition[];
        /**
         * A set of memebers. The value can be "allUsers", "user:{email}" or "group:{email}".
         */
        members?: string[];
        /**
         * The role full name in roles/{id} format.
         */
        role?: string;
    }

    export interface PolicyIamPolicyBindingCondition {
        /**
         * The accessible database full name in instances/{instance resource id}/databases/{database name} format
         */
        database?: string;
        /**
         * The expiration timestamp in YYYY-MM-DDThh:mm:ssZ format
         */
        expireTimestamp?: string;
        /**
         * The export row limit for exporter role
         */
        rowLimit?: number;
        /**
         * The accessible schema in the database
         */
        schema?: string;
        /**
         * The accessible table list
         */
        tables?: string[];
    }

}

export namespace Instance {
    export interface GetListInstance {
        /**
         * Whether assign license for this instance or not.
         */
        activation: boolean;
        dataSources: outputs.Instance.GetListInstanceDataSource[];
        /**
         * The instance engine. Support MYSQL, POSTGRES, TIDB, SNOWFLAKE, CLICKHOUSE, MONGODB, SQLITE, REDIS, ORACLE, SPANNER, MSSQL, REDSHIFT, MARIADB, OCEANBASE, COCKROACHDB.
         */
        engine: string;
        /**
         * The engine version.
         */
        engineVersion: string;
        /**
         * The environment name for your instance in "environments/{resource id}" format.
         */
        environment: string;
        /**
         * The external console URL managing this instance (e.g. AWS RDS console, your in-house DB instance console)
         */
        externalLink: string;
        /**
         * The maximum number of connections. The default value is 10.
         */
        maximumConnections: number;
        /**
         * The instance full name in instances/{resource id} format.
         */
        name: string;
        /**
         * The instance unique resource id.
         */
        resourceId: string;
        /**
         * How often the instance is synced in seconds. Default 0, means never sync.
         */
        syncInterval: number;
        /**
         * The instance title.
         */
        title: string;
    }

    export interface GetListInstanceDataSource {
        /**
         * The database for the instance, you can set this if the engine type is POSTGRES.
         */
        database: string;
        /**
         * The external secret to get the database password. Learn more: https://www.bytebase.com/docs/get-started/instance/#use-external-secret-manager
         */
        externalSecrets: outputs.Instance.GetListInstanceDataSourceExternalSecret[];
        /**
         * Host or socket for your instance, or the account name if the instance type is Snowflake.
         */
        host: string;
        /**
         * The unique data source id in this instance.
         */
        id: string;
        /**
         * The connection user password used by Bytebase to perform DDL and DML operations.
         */
        password: string;
        /**
         * The port for your instance.
         */
        port: string;
        /**
         * The CA certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB, CLICKHOUSE or COCKROACHDB.
         */
        sslCa: string;
        /**
         * The client certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB, CLICKHOUSE or COCKROACHDB.
         */
        sslCert: string;
        /**
         * The client key. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB, CLICKHOUSE or COCKROACHDB.
         */
        sslKey: string;
        /**
         * The data source type. Should be ADMIN or READ_ONLY.
         */
        type: string;
        /**
         * Enable SSL connection. Required to use SSL certificates.
         */
        useSsl: boolean;
        /**
         * The connection user name used by Bytebase to perform DDL and DML operations.
         */
        username: string;
    }

    export interface GetListInstanceDataSourceExternalSecret {
        /**
         * The AWS Secrets Manager to get the database password. Reference doc https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html
         */
        awsSecretsManagers: outputs.Instance.GetListInstanceDataSourceExternalSecretAwsSecretsManager[];
        /**
         * The GCP Secret Manager to get the database password. Reference doc https://cloud.google.com/secret-manager/docs
         */
        gcpSecretManagers: outputs.Instance.GetListInstanceDataSourceExternalSecretGcpSecretManager[];
        vaults: outputs.Instance.GetListInstanceDataSourceExternalSecretVault[];
    }

    export interface GetListInstanceDataSourceExternalSecretAwsSecretsManager {
        /**
         * The key name for the password.
         */
        passwordKeyName: string;
        /**
         * The secret name to store the password.
         */
        secretName: string;
    }

    export interface GetListInstanceDataSourceExternalSecretGcpSecretManager {
        /**
         * The secret name should be like "projects/{project-id}/secrets/{secret-id}".
         */
        secretName: string;
    }

    export interface GetListInstanceDataSourceExternalSecretVault {
        /**
         * The Vault app role to get the password.
         */
        appRoles: outputs.Instance.GetListInstanceDataSourceExternalSecretVaultAppRole[];
        /**
         * The name for secret engine.
         */
        engineName: string;
        /**
         * The key name for the password.
         */
        passwordKeyName: string;
        /**
         * The secret name in the engine to store the password.
         */
        secretName: string;
        token: string;
        /**
         * The Vault URL.
         */
        url: string;
    }

    export interface GetListInstanceDataSourceExternalSecretVaultAppRole {
        /**
         * The app role id.
         */
        roleId: string;
        /**
         * The secret id for the role without ttl.
         */
        secret: string;
        /**
         * The secret id type, can be PLAIN (plain text for the secret) or ENVIRONMENT (envirionment name for the secret).
         */
        secretType: string;
    }

}

export namespace Policy {
    export interface GetListPolicy {
        /**
         * Decide if the policy is enforced.
         */
        enforce: boolean;
        globalMaskingPolicy: outputs.Policy.GetListPolicyGlobalMaskingPolicy;
        /**
         * Decide if the policy should inherit from the parent.
         */
        inheritFromParent: boolean;
        maskingExceptionPolicy: outputs.Policy.GetListPolicyMaskingExceptionPolicy;
        /**
         * The policy full name
         */
        name: string;
        /**
         * The policy type.
         */
        type: string;
    }

    export interface GetListPolicyGlobalMaskingPolicy {
        rules: outputs.Policy.GetListPolicyGlobalMaskingPolicyRule[];
    }

    export interface GetListPolicyGlobalMaskingPolicyRule {
        /**
         * The condition expression
         */
        condition: string;
        /**
         * The unique rule id
         */
        id: string;
        /**
         * The semantic type id
         */
        semanticType: string;
        /**
         * The title for the rule
         */
        title?: string;
    }

    export interface GetListPolicyMaskingExceptionPolicy {
        exceptions: outputs.Policy.GetListPolicyMaskingExceptionPolicyException[];
    }

    export interface GetListPolicyMaskingExceptionPolicyException {
        action: string;
        column: string;
        /**
         * The database full name in instances/{instance resource id}/databases/{database name} format
         */
        database: string;
        /**
         * The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
         */
        expireTimestamp: string;
        /**
         * The member in user:{email} or group:{email} format.
         */
        member: string;
        /**
         * The reason for the masking exemption
         */
        reason?: string;
        schema: string;
        table: string;
    }

}

export namespace Project {
    export interface GetListProject {
        /**
         * Allow modifying statement after issue is created.
         */
        allowModifyStatement: boolean;
        /**
         * Whether to allow the issue creator to self-approve the issue.
         */
        allowSelfApproval: boolean;
        /**
         * Whether to automatically enable backup.
         */
        autoEnableBackup: boolean;
        /**
         * Enable auto resolve issue.
         */
        autoResolveIssue: boolean;
        /**
         * The databases full name in the resource.
         */
        databases: string[];
        /**
         * Enforce issue title created by user instead of generated by Bytebase.
         */
        enforceIssueTitle: boolean;
        /**
         * The project full name in projects/{resource id} format.
         */
        name: string;
        /**
         * Whether to enable the database tenant mode for PostgreSQL. If enabled, the issue will be created with the pre-appended "set role <db_owner>" statement.
         */
        postgresDatabaseTenantMode: boolean;
        /**
         * The project unique resource id.
         */
        resourceId: string;
        /**
         * Whether to skip backup errors and continue the data migration.
         */
        skipBackupErrors: boolean;
        /**
         * The project title.
         */
        title: string;
        /**
         * The webhooks in the project.
         */
        webhooks: outputs.Project.GetListProjectWebhook[];
    }

    export interface GetListProjectWebhook {
        /**
         * If directMessage is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
         */
        directMessage?: boolean;
        /**
         * The webhook full name in projects/{resource id}/webhooks/{id} format.
         */
        name: string;
        /**
         * notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
         */
        notificationTypes: string[];
        /**
         * The webhook title
         */
        title: string;
        /**
         * The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
         */
        type: string;
        /**
         * The webhook URL
         */
        url: string;
    }

}

export namespace Review {
    export interface ConfigRule {
        /**
         * The comment for the rule.
         */
        comment: string;
        /**
         * The rule for the database engine.
         */
        engine: string;
        /**
         * The rule level.
         */
        level: string;
        /**
         * The payload is a JSON string that varies by rule type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/SQL*REVIEW*RULES_DOCUMENTATION.md#payload-structure-types for all details
         */
        payload: string;
        /**
         * The rule unique type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/SQL*REVIEW*RULES_DOCUMENTATION.md#rule-categories for all rules
         */
        type: string;
    }

    export interface GetConfigRule {
        /**
         * The comment for the rule.
         */
        comment: string;
        /**
         * The rule for the database engine.
         */
        engine: string;
        /**
         * The rule level.
         */
        level: string;
        /**
         * The payload for the rule.
         */
        payload: string;
        /**
         * The rule unique type. Check https://www.bytebase.com/docs/sql-review/review-rules for all rules
         */
        type: string;
    }

}

export namespace ReviewConfig {
    export interface GetListReviewConfig {
        /**
         * Enable the SQL review config
         */
        enabled: boolean;
        /**
         * The unique resource id for the review config.
         */
        resourceId: string;
        /**
         * Resources using the config. We support attach the review config for environments or projects with format {resurce}/{resource id}. For example, environments/test, projects/sample.
         */
        resources: string[];
        /**
         * The SQL review rules.
         */
        rules: outputs.ReviewConfig.GetListReviewConfigRule[];
        /**
         * The title for the review config.
         */
        title: string;
    }

    export interface GetListReviewConfigRule {
        /**
         * The comment for the rule.
         */
        comment: string;
        /**
         * The rule for the database engine.
         */
        engine: string;
        /**
         * The rule level.
         */
        level: string;
        /**
         * The payload for the rule.
         */
        payload: string;
        /**
         * The rule unique type. Check https://www.bytebase.com/docs/sql-review/review-rules for all rules
         */
        type: string;
    }

}

export namespace Risk {
    export interface GetListRisk {
        /**
         * The risk active.
         */
        active: boolean;
        /**
         * The risk condition.
         */
        condition: string;
        /**
         * The risk level.
         */
        level: number;
        /**
         * The risk full name in risks/{resource id} format.
         */
        name: string;
        /**
         * The risk source.
         */
        source: string;
        /**
         * The risk title.
         */
        title: string;
    }

}

export namespace Role {
    export interface GetListRole {
        /**
         * The role description.
         */
        description: string;
        /**
         * The role full name in roles/{resource id} format.
         */
        name: string;
        /**
         * The role permissions.
         */
        permissions: string[];
        /**
         * The role unique resource id.
         */
        resourceId: string;
        /**
         * The role title.
         */
        title: string;
        /**
         * The role type.
         */
        type: string;
    }

}

export namespace User {
    export interface GetListUser {
        /**
         * The user email.
         */
        email: string;
        /**
         * The user last change password time.
         */
        lastChangePasswordTime: string;
        /**
         * The user last login time.
         */
        lastLoginTime: string;
        /**
         * The mfaEnabled flag means if the user has enabled MFA.
         */
        mfaEnabled: boolean;
        /**
         * The user name in users/{user id or email} format.
         */
        name: string;
        /**
         * The user phone.
         */
        phone: string;
        /**
         * Source means where the user comes from. For now we support Entra ID SCIM sync, so the source could be Entra ID.
         */
        source: string;
        /**
         * The user is deleted or not.
         */
        state: string;
        /**
         * The user title.
         */
        title: string;
        /**
         * The user type.
         */
        type: string;
    }

}
