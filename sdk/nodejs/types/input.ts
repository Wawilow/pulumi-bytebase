// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DatabaseCatalog {
    schemas: pulumi.Input<pulumi.Input<inputs.DatabaseCatalogSchema>[]>;
}

export interface DatabaseCatalogSchema {
    name?: pulumi.Input<string>;
    tables: pulumi.Input<pulumi.Input<inputs.DatabaseCatalogSchemaTable>[]>;
}

export interface DatabaseCatalogSchemaTable {
    /**
     * The classification id
     */
    classification?: pulumi.Input<string>;
    columns: pulumi.Input<pulumi.Input<inputs.DatabaseCatalogSchemaTableColumn>[]>;
    name: pulumi.Input<string>;
}

export interface DatabaseCatalogSchemaTableColumn {
    /**
     * The classification id
     */
    classification?: pulumi.Input<string>;
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
    /**
     * The semantic type id
     */
    semanticType?: pulumi.Input<string>;
}

export interface GetPolicyDataSourceQueryPolicy {
    /**
     * Disallow running DDL statements in the SQL editor.
     */
    disallowDdl?: boolean;
    /**
     * Disallow running DML statements in the SQL editor.
     */
    disallowDml?: boolean;
    /**
     * RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
     */
    restriction?: string;
}

export interface GetPolicyDataSourceQueryPolicyArgs {
    /**
     * Disallow running DDL statements in the SQL editor.
     */
    disallowDdl?: pulumi.Input<boolean>;
    /**
     * Disallow running DML statements in the SQL editor.
     */
    disallowDml?: pulumi.Input<boolean>;
    /**
     * RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
     */
    restriction?: pulumi.Input<string>;
}

export interface GetPolicyDisableCopyDataPolicy {
    /**
     * Restrict data copying
     */
    enable: boolean;
}

export interface GetPolicyDisableCopyDataPolicyArgs {
    /**
     * Restrict data copying
     */
    enable: pulumi.Input<boolean>;
}

export interface GetPolicyGlobalMaskingPolicy {
    rules?: inputs.GetPolicyGlobalMaskingPolicyRule[];
}

export interface GetPolicyGlobalMaskingPolicyArgs {
    rules?: pulumi.Input<pulumi.Input<inputs.GetPolicyGlobalMaskingPolicyRuleArgs>[]>;
}

export interface GetPolicyGlobalMaskingPolicyRule {
    /**
     * The condition expression
     */
    condition: string;
    /**
     * The unique rule id
     */
    id: string;
    /**
     * The semantic type id
     */
    semanticType: string;
    /**
     * The title for the rule
     */
    title?: string;
}

export interface GetPolicyGlobalMaskingPolicyRuleArgs {
    /**
     * The condition expression
     */
    condition: pulumi.Input<string>;
    /**
     * The unique rule id
     */
    id: pulumi.Input<string>;
    /**
     * The semantic type id
     */
    semanticType: pulumi.Input<string>;
    /**
     * The title for the rule
     */
    title?: pulumi.Input<string>;
}

export interface GetPolicyMaskingExceptionPolicy {
    exceptions?: inputs.GetPolicyMaskingExceptionPolicyException[];
}

export interface GetPolicyMaskingExceptionPolicyArgs {
    exceptions?: pulumi.Input<pulumi.Input<inputs.GetPolicyMaskingExceptionPolicyExceptionArgs>[]>;
}

export interface GetPolicyMaskingExceptionPolicyException {
    action: string;
    column?: string;
    /**
     * The database full name in instances/{instance resource id}/databases/{database name} format
     */
    database: string;
    /**
     * The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
     */
    expireTimestamp?: string;
    /**
     * The member in user:{email} or group:{email} format.
     */
    member: string;
    /**
     * The reason for the masking exemption
     */
    reason?: string;
    schema?: string;
    table?: string;
}

export interface GetPolicyMaskingExceptionPolicyExceptionArgs {
    action: pulumi.Input<string>;
    column?: pulumi.Input<string>;
    /**
     * The database full name in instances/{instance resource id}/databases/{database name} format
     */
    database: pulumi.Input<string>;
    /**
     * The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
     */
    expireTimestamp?: pulumi.Input<string>;
    /**
     * The member in user:{email} or group:{email} format.
     */
    member: pulumi.Input<string>;
    /**
     * The reason for the masking exemption
     */
    reason?: pulumi.Input<string>;
    schema?: pulumi.Input<string>;
    table?: pulumi.Input<string>;
}

export interface GetPolicyRolloutPolicy {
    /**
     * If all check pass, the change will be rolled out and executed automatically.
     */
    automatic?: boolean;
    /**
     * If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
     */
    roles?: string[];
}

export interface GetPolicyRolloutPolicyArgs {
    /**
     * If all check pass, the change will be rolled out and executed automatically.
     */
    automatic?: pulumi.Input<boolean>;
    /**
     * If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
     */
    roles?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GetSettingApprovalFlow {
    rules?: inputs.GetSettingApprovalFlowRule[];
}

export interface GetSettingApprovalFlowArgs {
    rules?: pulumi.Input<pulumi.Input<inputs.GetSettingApprovalFlowRuleArgs>[]>;
}

export interface GetSettingApprovalFlowRule {
    /**
     * Match any condition will trigger this approval flow.
     */
    conditions?: inputs.GetSettingApprovalFlowRuleCondition[];
    flows?: inputs.GetSettingApprovalFlowRuleFlow[];
}

export interface GetSettingApprovalFlowRuleArgs {
    /**
     * Match any condition will trigger this approval flow.
     */
    conditions?: pulumi.Input<pulumi.Input<inputs.GetSettingApprovalFlowRuleConditionArgs>[]>;
    flows?: pulumi.Input<pulumi.Input<inputs.GetSettingApprovalFlowRuleFlowArgs>[]>;
}

export interface GetSettingApprovalFlowRuleCondition {
    level?: string;
    source?: string;
}

export interface GetSettingApprovalFlowRuleConditionArgs {
    level?: pulumi.Input<string>;
    source?: pulumi.Input<string>;
}

export interface GetSettingApprovalFlowRuleFlow {
    description?: string;
    /**
     * Approval flow following the step order.
     */
    steps?: inputs.GetSettingApprovalFlowRuleFlowStep[];
    title?: string;
}

export interface GetSettingApprovalFlowRuleFlowArgs {
    description?: pulumi.Input<string>;
    /**
     * Approval flow following the step order.
     */
    steps?: pulumi.Input<pulumi.Input<inputs.GetSettingApprovalFlowRuleFlowStepArgs>[]>;
    title?: pulumi.Input<string>;
}

export interface GetSettingApprovalFlowRuleFlowStep {
    /**
     * The role require to review in this step
     */
    role: string;
}

export interface GetSettingApprovalFlowRuleFlowStepArgs {
    /**
     * The role require to review in this step
     */
    role: pulumi.Input<string>;
}

export interface GetSettingClassification {
    /**
     * If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
     */
    classificationFromConfig?: boolean;
    classifications: inputs.GetSettingClassificationClassification[];
    /**
     * The classification unique uuid.
     */
    id: string;
    levels: inputs.GetSettingClassificationLevel[];
    /**
     * The classification title. Optional.
     */
    title: string;
}

export interface GetSettingClassificationArgs {
    /**
     * If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
     */
    classificationFromConfig?: pulumi.Input<boolean>;
    classifications: pulumi.Input<pulumi.Input<inputs.GetSettingClassificationClassificationArgs>[]>;
    /**
     * The classification unique uuid.
     */
    id: pulumi.Input<string>;
    levels: pulumi.Input<pulumi.Input<inputs.GetSettingClassificationLevelArgs>[]>;
    /**
     * The classification title. Optional.
     */
    title: pulumi.Input<string>;
}

export interface GetSettingClassificationClassification {
    /**
     * The classification description.
     */
    description?: string;
    /**
     * The classification unique id, must in {number}-{number} format.
     */
    id: string;
    /**
     * The classification level id.
     */
    level?: string;
    /**
     * The classification title.
     */
    title: string;
}

export interface GetSettingClassificationClassificationArgs {
    /**
     * The classification description.
     */
    description?: pulumi.Input<string>;
    /**
     * The classification unique id, must in {number}-{number} format.
     */
    id: pulumi.Input<string>;
    /**
     * The classification level id.
     */
    level?: pulumi.Input<string>;
    /**
     * The classification title.
     */
    title: pulumi.Input<string>;
}

export interface GetSettingClassificationLevel {
    /**
     * The classification level description.
     */
    description?: string;
    /**
     * The classification level unique uuid.
     */
    id: string;
    /**
     * The classification level title.
     */
    title: string;
}

export interface GetSettingClassificationLevelArgs {
    /**
     * The classification level description.
     */
    description?: pulumi.Input<string>;
    /**
     * The classification level unique uuid.
     */
    id: pulumi.Input<string>;
    /**
     * The classification level title.
     */
    title: pulumi.Input<string>;
}

export interface GetSettingEnvironmentSetting {
    environments?: inputs.GetSettingEnvironmentSettingEnvironment[];
}

export interface GetSettingEnvironmentSettingArgs {
    environments?: pulumi.Input<pulumi.Input<inputs.GetSettingEnvironmentSettingEnvironmentArgs>[]>;
}

export interface GetSettingEnvironmentSettingEnvironment {
    /**
     * The environment color.
     */
    color?: string;
    /**
     * The environment unique id.
     */
    id: string;
    /**
     * The environment readonly name in environments/{id} format.
     */
    name?: string;
    /**
     * The environment is protected or not.
     */
    protected?: boolean;
    /**
     * The environment display name.
     */
    title: string;
}

export interface GetSettingEnvironmentSettingEnvironmentArgs {
    /**
     * The environment color.
     */
    color?: pulumi.Input<string>;
    /**
     * The environment unique id.
     */
    id: pulumi.Input<string>;
    /**
     * The environment readonly name in environments/{id} format.
     */
    name?: pulumi.Input<string>;
    /**
     * The environment is protected or not.
     */
    protected?: pulumi.Input<boolean>;
    /**
     * The environment display name.
     */
    title: pulumi.Input<string>;
}

export interface GetSettingPasswordRestriction {
    /**
     * min_length is the minimum length for password, should no less than 8.
     */
    minLength?: number;
    /**
     * password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
     */
    passwordRotationInSeconds?: number;
    /**
     * require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
     */
    requireLetter?: boolean;
    /**
     * require_number requires the password must contains at least one number.
     */
    requireNumber?: boolean;
    /**
     * require*reset*password*for*first_login requires users to reset their password after the 1st login.
     */
    requireResetPasswordForFirstLogin?: boolean;
    /**
     * require*special*character requires the password must contains at least one special character.
     */
    requireSpecialCharacter?: boolean;
    /**
     * require*uppercase*letter requires the password must contains at least one upper case letter.
     */
    requireUppercaseLetter?: boolean;
}

export interface GetSettingPasswordRestrictionArgs {
    /**
     * min_length is the minimum length for password, should no less than 8.
     */
    minLength?: pulumi.Input<number>;
    /**
     * password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
     */
    passwordRotationInSeconds?: pulumi.Input<number>;
    /**
     * require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
     */
    requireLetter?: pulumi.Input<boolean>;
    /**
     * require_number requires the password must contains at least one number.
     */
    requireNumber?: pulumi.Input<boolean>;
    /**
     * require*reset*password*for*first_login requires users to reset their password after the 1st login.
     */
    requireResetPasswordForFirstLogin?: pulumi.Input<boolean>;
    /**
     * require*special*character requires the password must contains at least one special character.
     */
    requireSpecialCharacter?: pulumi.Input<boolean>;
    /**
     * require*uppercase*letter requires the password must contains at least one upper case letter.
     */
    requireUppercaseLetter?: pulumi.Input<boolean>;
}

export interface GetSettingSemanticType {
    /**
     * The semantic type algorithm. Required.
     */
    algorithm?: inputs.GetSettingSemanticTypeAlgorithm;
    /**
     * The semantic type description. Optional.
     */
    description?: string;
    /**
     * The semantic type unique uuid.
     */
    id: string;
    /**
     * The semantic type title. Required.
     */
    title: string;
}

export interface GetSettingSemanticTypeArgs {
    /**
     * The semantic type algorithm. Required.
     */
    algorithm?: pulumi.Input<inputs.GetSettingSemanticTypeAlgorithmArgs>;
    /**
     * The semantic type description. Optional.
     */
    description?: pulumi.Input<string>;
    /**
     * The semantic type unique uuid.
     */
    id: pulumi.Input<string>;
    /**
     * The semantic type title. Required.
     */
    title: pulumi.Input<string>;
}

export interface GetSettingSemanticTypeAlgorithm {
    fullMask?: inputs.GetSettingSemanticTypeAlgorithmFullMask;
    innerOuterMask?: inputs.GetSettingSemanticTypeAlgorithmInnerOuterMask;
    md5Mask?: inputs.GetSettingSemanticTypeAlgorithmMd5Mask;
    rangeMask?: inputs.GetSettingSemanticTypeAlgorithmRangeMask;
}

export interface GetSettingSemanticTypeAlgorithmArgs {
    fullMask?: pulumi.Input<inputs.GetSettingSemanticTypeAlgorithmFullMaskArgs>;
    innerOuterMask?: pulumi.Input<inputs.GetSettingSemanticTypeAlgorithmInnerOuterMaskArgs>;
    md5Mask?: pulumi.Input<inputs.GetSettingSemanticTypeAlgorithmMd5MaskArgs>;
    rangeMask?: pulumi.Input<inputs.GetSettingSemanticTypeAlgorithmRangeMaskArgs>;
}

export interface GetSettingSemanticTypeAlgorithmFullMask {
    /**
     * Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
     */
    substitution: string;
}

export interface GetSettingSemanticTypeAlgorithmFullMaskArgs {
    /**
     * Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
     */
    substitution: pulumi.Input<string>;
}

export interface GetSettingSemanticTypeAlgorithmInnerOuterMask {
    /**
     * The length of prefix.
     */
    prefixLen: number;
    /**
     * Substitution is the string used to replace the inner or outer substring.
     */
    substitution: string;
    /**
     * The length of suffix.
     */
    suffixLen: number;
    /**
     * INNER or OUTER.
     */
    type: string;
}

export interface GetSettingSemanticTypeAlgorithmInnerOuterMaskArgs {
    /**
     * The length of prefix.
     */
    prefixLen: pulumi.Input<number>;
    /**
     * Substitution is the string used to replace the inner or outer substring.
     */
    substitution: pulumi.Input<string>;
    /**
     * The length of suffix.
     */
    suffixLen: pulumi.Input<number>;
    /**
     * INNER or OUTER.
     */
    type: pulumi.Input<string>;
}

export interface GetSettingSemanticTypeAlgorithmMd5Mask {
    /**
     * Salt is the salt value to generate a different hash that with the word alone.
     */
    salt: string;
}

export interface GetSettingSemanticTypeAlgorithmMd5MaskArgs {
    /**
     * Salt is the salt value to generate a different hash that with the word alone.
     */
    salt: pulumi.Input<string>;
}

export interface GetSettingSemanticTypeAlgorithmRangeMask {
    slices?: inputs.GetSettingSemanticTypeAlgorithmRangeMaskSlice[];
}

export interface GetSettingSemanticTypeAlgorithmRangeMaskArgs {
    slices?: pulumi.Input<pulumi.Input<inputs.GetSettingSemanticTypeAlgorithmRangeMaskSliceArgs>[]>;
}

export interface GetSettingSemanticTypeAlgorithmRangeMaskSlice {
    /**
     * End is the stop index of the original value, should be less than the length of the original value.
     */
    end: number;
    /**
     * Start is the start index of the original value, start from 0 and should be less than stop.
     */
    start: number;
    /**
     * Substitution is the string used to replace the OriginalValue[start:end).
     */
    substitution: string;
}

export interface GetSettingSemanticTypeAlgorithmRangeMaskSliceArgs {
    /**
     * End is the stop index of the original value, should be less than the length of the original value.
     */
    end: pulumi.Input<number>;
    /**
     * Start is the start index of the original value, start from 0 and should be less than stop.
     */
    start: pulumi.Input<number>;
    /**
     * Substitution is the string used to replace the OriginalValue[start:end).
     */
    substitution: pulumi.Input<string>;
}

export interface GetSettingSqlQueryRestriction {
    /**
     * The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
     */
    maximumResultRows?: number;
    /**
     * The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
     */
    maximumResultSize?: number;
}

export interface GetSettingSqlQueryRestrictionArgs {
    /**
     * The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
     */
    maximumResultRows?: pulumi.Input<number>;
    /**
     * The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
     */
    maximumResultSize?: pulumi.Input<number>;
}

export interface GetSettingWorkspaceProfile {
    /**
     * Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
     */
    announcement?: inputs.GetSettingWorkspaceProfileAnnouncement;
    /**
     * The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
     */
    databaseChangeMode?: string;
    /**
     * Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
     */
    disallowPasswordSignin?: boolean;
    /**
     * Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
     */
    disallowSignup?: boolean;
    /**
     * The workspace domain, e.g. bytebase.com. Required for the group
     */
    domains?: string[];
    /**
     * Only user and group from the domains can be created and login.
     */
    enforceIdentityDomain?: boolean;
    /**
     * The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
     */
    externalUrl?: string;
    /**
     * The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
     */
    maximumRoleExpirationInSeconds?: number;
    /**
     * The duration for login token in seconds. The duration should be at least 3600 (one hour).
     */
    tokenDurationInSeconds?: number;
}

export interface GetSettingWorkspaceProfileArgs {
    /**
     * Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
     */
    announcement?: pulumi.Input<inputs.GetSettingWorkspaceProfileAnnouncementArgs>;
    /**
     * The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
     */
    databaseChangeMode?: pulumi.Input<string>;
    /**
     * Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
     */
    disallowPasswordSignin?: pulumi.Input<boolean>;
    /**
     * Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
     */
    disallowSignup?: pulumi.Input<boolean>;
    /**
     * The workspace domain, e.g. bytebase.com. Required for the group
     */
    domains?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Only user and group from the domains can be created and login.
     */
    enforceIdentityDomain?: pulumi.Input<boolean>;
    /**
     * The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
     */
    externalUrl?: pulumi.Input<string>;
    /**
     * The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
     */
    maximumRoleExpirationInSeconds?: pulumi.Input<number>;
    /**
     * The duration for login token in seconds. The duration should be at least 3600 (one hour).
     */
    tokenDurationInSeconds?: pulumi.Input<number>;
}

export interface GetSettingWorkspaceProfileAnnouncement {
    /**
     * The alert level of announcement
     */
    level: string;
    /**
     * The optional link, user can follow the link to check extra details
     */
    link?: string;
    /**
     * The text of announcement. Leave it as empty string can clear the announcement
     */
    text: string;
}

export interface GetSettingWorkspaceProfileAnnouncementArgs {
    /**
     * The alert level of announcement
     */
    level: pulumi.Input<string>;
    /**
     * The optional link, user can follow the link to check extra details
     */
    link?: pulumi.Input<string>;
    /**
     * The text of announcement. Leave it as empty string can clear the announcement
     */
    text: pulumi.Input<string>;
}

export interface GroupMember {
    /**
     * The member in users/{email} format.
     */
    member: pulumi.Input<string>;
    /**
     * The member's role in the group, should be OWNER or MEMBER.
     */
    role: pulumi.Input<string>;
}

export interface InstanceDataSource {
    /**
     * The database for the instance, you can set this if the engine type is POSTGRES.
     */
    database?: pulumi.Input<string>;
    /**
     * The external secret to get the database password. Learn more: https://www.bytebase.com/docs/get-started/instance/#use-external-secret-manager
     */
    externalSecret?: pulumi.Input<inputs.InstanceDataSourceExternalSecret>;
    /**
     * Host or socket for your instance, or the account name if the instance type is Snowflake.
     */
    host: pulumi.Input<string>;
    /**
     * The unique data source id in this instance.
     */
    id: pulumi.Input<string>;
    /**
     * The connection user password used by Bytebase to perform DDL and DML operations.
     */
    password?: pulumi.Input<string>;
    /**
     * The port for your instance.
     */
    port: pulumi.Input<string>;
    /**
     * The CA certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
     */
    sslCa?: pulumi.Input<string>;
    /**
     * The client certificate. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
     */
    sslCert?: pulumi.Input<string>;
    /**
     * The client key. Optional, you can set this if the engine type is MYSQL, POSTGRES, TIDB or CLICKHOUSE.
     */
    sslKey?: pulumi.Input<string>;
    /**
     * The data source type. Should be ADMIN or READ_ONLY.
     */
    type: pulumi.Input<string>;
    /**
     * Enable SSL connection. Required to use SSL certificates.
     */
    useSsl?: pulumi.Input<boolean>;
    /**
     * The connection user name used by Bytebase to perform DDL and DML operations.
     */
    username?: pulumi.Input<string>;
}

export interface InstanceDataSourceExternalSecret {
    /**
     * The AWS Secrets Manager to get the database password. Reference doc https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html
     */
    awsSecretsManager?: pulumi.Input<inputs.InstanceDataSourceExternalSecretAwsSecretsManager>;
    /**
     * The GCP Secret Manager to get the database password. Reference doc https://cloud.google.com/secret-manager/docs
     */
    gcpSecretManager?: pulumi.Input<inputs.InstanceDataSourceExternalSecretGcpSecretManager>;
    vault?: pulumi.Input<inputs.InstanceDataSourceExternalSecretVault>;
}

export interface InstanceDataSourceExternalSecretAwsSecretsManager {
    /**
     * The key name for the password.
     */
    passwordKeyName: pulumi.Input<string>;
    /**
     * The secret name to store the password.
     */
    secretName: pulumi.Input<string>;
}

export interface InstanceDataSourceExternalSecretGcpSecretManager {
    /**
     * The secret name should be like "projects/{project-id}/secrets/{secret-id}".
     */
    secretName: pulumi.Input<string>;
}

export interface InstanceDataSourceExternalSecretVault {
    /**
     * The Vault app role to get the password.
     */
    appRole?: pulumi.Input<inputs.InstanceDataSourceExternalSecretVaultAppRole>;
    /**
     * The name for secret engine.
     */
    engineName: pulumi.Input<string>;
    /**
     * The key name for the password.
     */
    passwordKeyName: pulumi.Input<string>;
    /**
     * The secret name in the engine to store the password.
     */
    secretName: pulumi.Input<string>;
    token?: pulumi.Input<string>;
    /**
     * The Vault URL.
     */
    url: pulumi.Input<string>;
}

export interface InstanceDataSourceExternalSecretVaultAppRole {
    /**
     * The app role id.
     */
    roleId: pulumi.Input<string>;
    /**
     * The secret id for the role without ttl.
     */
    secret: pulumi.Input<string>;
    /**
     * The secret id type, can be PLAIN (plain text for the secret) or ENVIRONMENT (envirionment name for the secret).
     */
    secretType: pulumi.Input<string>;
}

export interface PolicyDataSourceQueryPolicy {
    /**
     * Disallow running DDL statements in the SQL editor.
     */
    disallowDdl?: pulumi.Input<boolean>;
    /**
     * Disallow running DML statements in the SQL editor.
     */
    disallowDml?: pulumi.Input<boolean>;
    /**
     * RESTRICTION_UNSPECIFIED means no restriction; FALLBACK will allows to query admin data sources when there is no read-only data source; DISALLOW will always disallow to query admin data sources.
     */
    restriction?: pulumi.Input<string>;
}

export interface PolicyDisableCopyDataPolicy {
    /**
     * Restrict data copying
     */
    enable: pulumi.Input<boolean>;
}

export interface PolicyGlobalMaskingPolicy {
    rules?: pulumi.Input<pulumi.Input<inputs.PolicyGlobalMaskingPolicyRule>[]>;
}

export interface PolicyGlobalMaskingPolicyRule {
    /**
     * The condition expression
     */
    condition: pulumi.Input<string>;
    /**
     * The unique rule id
     */
    id: pulumi.Input<string>;
    /**
     * The semantic type id
     */
    semanticType: pulumi.Input<string>;
    /**
     * The title for the rule
     */
    title?: pulumi.Input<string>;
}

export interface PolicyMaskingExceptionPolicy {
    exceptions?: pulumi.Input<pulumi.Input<inputs.PolicyMaskingExceptionPolicyException>[]>;
}

export interface PolicyMaskingExceptionPolicyException {
    action: pulumi.Input<string>;
    column?: pulumi.Input<string>;
    /**
     * The database full name in instances/{instance resource id}/databases/{database name} format
     */
    database: pulumi.Input<string>;
    /**
     * The expiration timestamp in YYYY-MM-DDThh:mm:ss.000Z format
     */
    expireTimestamp?: pulumi.Input<string>;
    /**
     * The member in user:{email} or group:{email} format.
     */
    member: pulumi.Input<string>;
    /**
     * The reason for the masking exemption
     */
    reason?: pulumi.Input<string>;
    schema?: pulumi.Input<string>;
    table?: pulumi.Input<string>;
}

export interface PolicyRolloutPolicy {
    /**
     * If all check pass, the change will be rolled out and executed automatically.
     */
    automatic?: pulumi.Input<boolean>;
    /**
     * If any roles are specified, Bytebase requires users with those roles to manually roll out the change.
     */
    roles?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ProjectWebhook {
    /**
     * If directMessage is set, the notification is sent directly to the persons and url will be ignored. Require IM integration for this function to work.
     */
    directMessage?: pulumi.Input<boolean>;
    /**
     * The webhook full name in projects/{resource id}/webhooks/{id} format.
     */
    name?: pulumi.Input<string>;
    /**
     * notification_types is the list of activities types that the webhook is interested in. Bytebase will only send notifications to the webhook if the activity type is in the list.
     */
    notificationTypes: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The webhook title
     */
    title: pulumi.Input<string>;
    /**
     * The webhook type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/project_service.proto#L449 for support types.
     */
    type: pulumi.Input<string>;
    /**
     * The webhook URL
     */
    url: pulumi.Input<string>;
}

export interface SettingApprovalFlow {
    rules: pulumi.Input<pulumi.Input<inputs.SettingApprovalFlowRule>[]>;
}

export interface SettingApprovalFlowRule {
    /**
     * Match any condition will trigger this approval flow.
     */
    conditions?: pulumi.Input<pulumi.Input<inputs.SettingApprovalFlowRuleCondition>[]>;
    flows: pulumi.Input<pulumi.Input<inputs.SettingApprovalFlowRuleFlow>[]>;
}

export interface SettingApprovalFlowRuleCondition {
    level?: pulumi.Input<string>;
    source?: pulumi.Input<string>;
}

export interface SettingApprovalFlowRuleFlow {
    description?: pulumi.Input<string>;
    /**
     * Approval flow following the step order.
     */
    steps: pulumi.Input<pulumi.Input<inputs.SettingApprovalFlowRuleFlowStep>[]>;
    title: pulumi.Input<string>;
}

export interface SettingApprovalFlowRuleFlowStep {
    /**
     * The role require to review in this step
     */
    role: pulumi.Input<string>;
}

export interface SettingClassification {
    /**
     * If true, we will only store the classification in the config. Otherwise we will get the classification from table/column comment, and write back to the schema metadata.
     */
    classificationFromConfig?: pulumi.Input<boolean>;
    classifications: pulumi.Input<pulumi.Input<inputs.SettingClassificationClassification>[]>;
    /**
     * The classification unique uuid.
     */
    id: pulumi.Input<string>;
    levels: pulumi.Input<pulumi.Input<inputs.SettingClassificationLevel>[]>;
    /**
     * The classification title. Optional.
     */
    title: pulumi.Input<string>;
}

export interface SettingClassificationClassification {
    /**
     * The classification description.
     */
    description?: pulumi.Input<string>;
    /**
     * The classification unique id, must in {number}-{number} format.
     */
    id: pulumi.Input<string>;
    /**
     * The classification level id.
     */
    level?: pulumi.Input<string>;
    /**
     * The classification title.
     */
    title: pulumi.Input<string>;
}

export interface SettingClassificationLevel {
    /**
     * The classification level description.
     */
    description?: pulumi.Input<string>;
    /**
     * The classification level unique uuid.
     */
    id: pulumi.Input<string>;
    /**
     * The classification level title.
     */
    title: pulumi.Input<string>;
}

export interface SettingEnvironmentSetting {
    environments: pulumi.Input<pulumi.Input<inputs.SettingEnvironmentSettingEnvironment>[]>;
}

export interface SettingEnvironmentSettingEnvironment {
    /**
     * The environment color.
     */
    color?: pulumi.Input<string>;
    /**
     * The environment unique id.
     */
    id: pulumi.Input<string>;
    /**
     * The environment readonly name in environments/{id} format.
     */
    name?: pulumi.Input<string>;
    /**
     * The environment is protected or not.
     */
    protected?: pulumi.Input<boolean>;
    /**
     * The environment display name.
     */
    title: pulumi.Input<string>;
}

export interface SettingPasswordRestriction {
    /**
     * min_length is the minimum length for password, should no less than 8.
     */
    minLength?: pulumi.Input<number>;
    /**
     * password_rotation requires users to reset their password after the duration. The duration should be at least 86400 (one day).
     */
    passwordRotationInSeconds?: pulumi.Input<number>;
    /**
     * require_letter requires the password must contains at least one letter, regardless of upper case or lower case.
     */
    requireLetter?: pulumi.Input<boolean>;
    /**
     * require_number requires the password must contains at least one number.
     */
    requireNumber?: pulumi.Input<boolean>;
    /**
     * require*reset*password*for*first_login requires users to reset their password after the 1st login.
     */
    requireResetPasswordForFirstLogin?: pulumi.Input<boolean>;
    /**
     * require*special*character requires the password must contains at least one special character.
     */
    requireSpecialCharacter?: pulumi.Input<boolean>;
    /**
     * require*uppercase*letter requires the password must contains at least one upper case letter.
     */
    requireUppercaseLetter?: pulumi.Input<boolean>;
}

export interface SettingSemanticType {
    /**
     * The semantic type algorithm. Required.
     */
    algorithm?: pulumi.Input<inputs.SettingSemanticTypeAlgorithm>;
    /**
     * The semantic type description. Optional.
     */
    description?: pulumi.Input<string>;
    /**
     * The semantic type unique uuid.
     */
    id: pulumi.Input<string>;
    /**
     * The semantic type title. Required.
     */
    title: pulumi.Input<string>;
}

export interface SettingSemanticTypeAlgorithm {
    fullMask?: pulumi.Input<inputs.SettingSemanticTypeAlgorithmFullMask>;
    innerOuterMask?: pulumi.Input<inputs.SettingSemanticTypeAlgorithmInnerOuterMask>;
    md5Mask?: pulumi.Input<inputs.SettingSemanticTypeAlgorithmMd5Mask>;
    rangeMask?: pulumi.Input<inputs.SettingSemanticTypeAlgorithmRangeMask>;
}

export interface SettingSemanticTypeAlgorithmFullMask {
    /**
     * Substitution is the string used to replace the original value, the max length of the string is 16 bytes.
     */
    substitution: pulumi.Input<string>;
}

export interface SettingSemanticTypeAlgorithmInnerOuterMask {
    /**
     * The length of prefix.
     */
    prefixLen: pulumi.Input<number>;
    /**
     * Substitution is the string used to replace the inner or outer substring.
     */
    substitution: pulumi.Input<string>;
    /**
     * The length of suffix.
     */
    suffixLen: pulumi.Input<number>;
    /**
     * INNER or OUTER.
     */
    type: pulumi.Input<string>;
}

export interface SettingSemanticTypeAlgorithmMd5Mask {
    /**
     * Salt is the salt value to generate a different hash that with the word alone.
     */
    salt: pulumi.Input<string>;
}

export interface SettingSemanticTypeAlgorithmRangeMask {
    slices?: pulumi.Input<pulumi.Input<inputs.SettingSemanticTypeAlgorithmRangeMaskSlice>[]>;
}

export interface SettingSemanticTypeAlgorithmRangeMaskSlice {
    /**
     * End is the stop index of the original value, should be less than the length of the original value.
     */
    end: pulumi.Input<number>;
    /**
     * Start is the start index of the original value, start from 0 and should be less than stop.
     */
    start: pulumi.Input<number>;
    /**
     * Substitution is the string used to replace the OriginalValue[start:end).
     */
    substitution: pulumi.Input<string>;
}

export interface SettingSqlQueryRestriction {
    /**
     * The return rows limit. If the value <= 0, will be treated as no limit. The default value is -1.
     */
    maximumResultRows?: pulumi.Input<number>;
    /**
     * The size limit in bytes. The default value is 100MB, we will use the default value if the setting not exists, or the limit <= 0.
     */
    maximumResultSize?: pulumi.Input<number>;
}

export interface SettingWorkspaceProfile {
    /**
     * Custom announcement. Will show as a banner in the Bytebase UI. Require ENTERPRISE subscription.
     */
    announcement?: pulumi.Input<inputs.SettingWorkspaceProfileAnnouncement>;
    /**
     * The workspace database change mode, support EDITOR or PIPELINE. Default PIPELINE
     */
    databaseChangeMode?: pulumi.Input<string>;
    /**
     * Whether to disallow password signin (except workspace admins). Require ENTERPRISE subscription
     */
    disallowPasswordSignin?: pulumi.Input<boolean>;
    /**
     * Disallow self-service signup, users can only be invited by the owner. Require PRO subscription.
     */
    disallowSignup?: pulumi.Input<boolean>;
    /**
     * The workspace domain, e.g. bytebase.com. Required for the group
     */
    domains?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Only user and group from the domains can be created and login.
     */
    enforceIdentityDomain?: pulumi.Input<boolean>;
    /**
     * The URL user visits Bytebase. The external URL is used for: 1. Constructing the correct callback URL when configuring the VCS provider. The callback URL points to the frontend; 2. Creating the correct webhook endpoint when configuring the project GitOps workflow. The webhook endpoint points to the backend.
     */
    externalUrl?: pulumi.Input<string>;
    /**
     * The max duration in seconds for role expired. If the value is less than or equal to 0, we will remove the setting. AKA no limit.
     */
    maximumRoleExpirationInSeconds?: pulumi.Input<number>;
    /**
     * The duration for login token in seconds. The duration should be at least 3600 (one hour).
     */
    tokenDurationInSeconds?: pulumi.Input<number>;
}

export interface SettingWorkspaceProfileAnnouncement {
    /**
     * The alert level of announcement
     */
    level: pulumi.Input<string>;
    /**
     * The optional link, user can follow the link to check extra details
     */
    link?: pulumi.Input<string>;
    /**
     * The text of announcement. Leave it as empty string can clear the announcement
     */
    text: pulumi.Input<string>;
}
export namespace Database {
}

export namespace DatabaseGroup {
}

export namespace Group {
}

export namespace Iam {
    export interface GetPolicyIamPolicy {
        /**
         * The binding in the IAM policy.
         */
        bindings?: inputs.Iam.GetPolicyIamPolicyBinding[];
    }

    export interface GetPolicyIamPolicyArgs {
        /**
         * The binding in the IAM policy.
         */
        bindings?: pulumi.Input<pulumi.Input<inputs.Iam.GetPolicyIamPolicyBindingArgs>[]>;
    }

    export interface GetPolicyIamPolicyBinding {
        /**
         * Match the condition limit.
         */
        conditions?: inputs.Iam.GetPolicyIamPolicyBindingCondition[];
        /**
         * A set of memebers. The value can be "allUsers", "user:{email}" or "group:{email}".
         */
        members?: string[];
        /**
         * The role full name in roles/{id} format.
         */
        role?: string;
    }

    export interface GetPolicyIamPolicyBindingArgs {
        /**
         * Match the condition limit.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.Iam.GetPolicyIamPolicyBindingConditionArgs>[]>;
        /**
         * A set of memebers. The value can be "allUsers", "user:{email}" or "group:{email}".
         */
        members?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The role full name in roles/{id} format.
         */
        role?: pulumi.Input<string>;
    }

    export interface GetPolicyIamPolicyBindingCondition {
        /**
         * The accessible database full name in instances/{instance resource id}/databases/{database name} format
         */
        database?: string;
        /**
         * The expiration timestamp in YYYY-MM-DDThh:mm:ssZ format
         */
        expireTimestamp?: string;
        /**
         * The export row limit for exporter role
         */
        rowLimit?: number;
        /**
         * The accessible schema in the database
         */
        schema?: string;
        /**
         * The accessible table list
         */
        tables?: string[];
    }

    export interface GetPolicyIamPolicyBindingConditionArgs {
        /**
         * The accessible database full name in instances/{instance resource id}/databases/{database name} format
         */
        database?: pulumi.Input<string>;
        /**
         * The expiration timestamp in YYYY-MM-DDThh:mm:ssZ format
         */
        expireTimestamp?: pulumi.Input<string>;
        /**
         * The export row limit for exporter role
         */
        rowLimit?: pulumi.Input<number>;
        /**
         * The accessible schema in the database
         */
        schema?: pulumi.Input<string>;
        /**
         * The accessible table list
         */
        tables?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PolicyIamPolicy {
        /**
         * The binding in the IAM policy.
         */
        bindings?: pulumi.Input<pulumi.Input<inputs.Iam.PolicyIamPolicyBinding>[]>;
    }

    export interface PolicyIamPolicyBinding {
        /**
         * Match the condition limit.
         */
        conditions?: pulumi.Input<pulumi.Input<inputs.Iam.PolicyIamPolicyBindingCondition>[]>;
        /**
         * A set of memebers. The value can be "allUsers", "user:{email}" or "group:{email}".
         */
        members?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The role full name in roles/{id} format.
         */
        role?: pulumi.Input<string>;
    }

    export interface PolicyIamPolicyBindingCondition {
        /**
         * The accessible database full name in instances/{instance resource id}/databases/{database name} format
         */
        database?: pulumi.Input<string>;
        /**
         * The expiration timestamp in YYYY-MM-DDThh:mm:ssZ format
         */
        expireTimestamp?: pulumi.Input<string>;
        /**
         * The export row limit for exporter role
         */
        rowLimit?: pulumi.Input<number>;
        /**
         * The accessible schema in the database
         */
        schema?: pulumi.Input<string>;
        /**
         * The accessible table list
         */
        tables?: pulumi.Input<pulumi.Input<string>[]>;
    }
}

export namespace Instance {
}

export namespace Policy {
}

export namespace Project {
}

export namespace Review {
    export interface ConfigRule {
        /**
         * The comment for the rule.
         */
        comment?: pulumi.Input<string>;
        /**
         * The rule for the database engine.
         */
        engine: pulumi.Input<string>;
        /**
         * The rule level.
         */
        level: pulumi.Input<string>;
        /**
         * The payload is a JSON string that varies by rule type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/SQL*REVIEW*RULES_DOCUMENTATION.md#payload-structure-types for all details
         */
        payload?: pulumi.Input<string>;
        /**
         * The rule unique type. Check https://github.com/bytebase/bytebase/blob/main/proto/v1/v1/SQL*REVIEW*RULES_DOCUMENTATION.md#rule-categories for all rules
         */
        type: pulumi.Input<string>;
    }

}

export namespace ReviewConfig {
}

export namespace Risk {
}

export namespace Role {
}

export namespace User {
}
